{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport { generatePrivate, getPublic, decrypt } from '@toruslabs/eccrypto';\nimport { post, generateJsonRPCObject, get, setAPIKey, setEmbedHost } from '@toruslabs/http-helpers';\nimport BN from 'bn.js';\nimport { ec } from 'elliptic';\nimport JsonStringify from 'json-stable-stringify';\nimport { keccak256, toChecksumAddress } from 'web3-utils';\nimport loglevel from 'loglevel';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nvar log = loglevel.getLogger('torus.js');\nlog.disableAll();\n\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nvar SomeError = /*#__PURE__*/function (_Error) {\n  _inherits(SomeError, _Error);\n\n  var _super = _createSuper$1(SomeError);\n\n  function SomeError(_ref) {\n    var _this;\n\n    var errors = _ref.errors,\n        responses = _ref.responses,\n        predicate = _ref.predicate;\n\n    _classCallCheck(this, SomeError);\n\n    _this = _super.call(this, 'Unable to resolve enough promises.');\n    _this.errors = errors;\n    _this.responses = responses;\n    _this.predicate = predicate;\n    return _this;\n  }\n\n  return _createClass(SomeError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar Some = function Some(promises, predicate) {\n  return new Promise(function (resolve, reject) {\n    var finishedCount = 0;\n    var sharedState = {\n      resolved: false\n    };\n    var errorArr = new Array(promises.length).fill(undefined);\n    var resultArr = new Array(promises.length).fill(undefined);\n    var predicateError;\n    promises.forEach(function (x, index) {\n      x.then(function (resp) {\n        resultArr[index] = resp;\n        return undefined;\n      }).catch(function (error) {\n        errorArr[index] = error;\n      }).finally(function () {\n        if (sharedState.resolved) return;\n        predicate(resultArr.slice(0), sharedState).then(function (data) {\n          sharedState.resolved = true;\n          resolve(data);\n          return undefined;\n        }).catch(function (error) {\n          // log only the last predicate error\n          predicateError = error;\n        }).finally(function (_) {\n          finishedCount += 1;\n\n          if (finishedCount === promises.length) {\n            var errors = Object.values(resultArr.reduce(function (acc, z) {\n              var _error$data;\n\n              var _ref2 = z || {},\n                  id = _ref2.id,\n                  error = _ref2.error;\n\n              if ((error === null || error === void 0 ? void 0 : (_error$data = error.data) === null || _error$data === void 0 ? void 0 : _error$data.length) > 0) {\n                if (error.data.startsWith('Error occurred while verifying params')) acc[id] = capitalizeFirstLetter(error.data);else acc[id] = error.data;\n              }\n\n              return acc;\n            }, {}));\n\n            if (errors.length > 0) {\n              // Format-able errors\n              var msg = errors.length > 1 ? \"\\n\".concat(errors.map(function (it) {\n                return \"\\u2022 \".concat(it);\n              }).join('\\n')) : errors[0];\n              reject(new Error(msg));\n            } else {\n              var _predicateError;\n\n              reject(new SomeError({\n                errors: errorArr,\n                responses: resultArr,\n                predicate: ((_predicateError = predicateError) === null || _predicateError === void 0 ? void 0 : _predicateError.message) || predicateError\n              }));\n            }\n          }\n        });\n      });\n    });\n  });\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar GetOrSetNonceError = /*#__PURE__*/function (_Error) {\n  _inherits(GetOrSetNonceError, _Error);\n\n  var _super = _createSuper(GetOrSetNonceError);\n\n  function GetOrSetNonceError() {\n    _classCallCheck(this, GetOrSetNonceError);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(GetOrSetNonceError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar kCombinations = function kCombinations(s, k) {\n  var set = s;\n\n  if (typeof set === 'number') {\n    set = Array.from({\n      length: set\n    }, function (_, i) {\n      return i;\n    });\n  }\n\n  if (k > set.length || k <= 0) {\n    return [];\n  }\n\n  if (k === set.length) {\n    return [set];\n  }\n\n  if (k === 1) {\n    return set.reduce(function (acc, cur) {\n      return [].concat(_toConsumableArray(acc), [[cur]]);\n    }, []);\n  }\n\n  var combs = [];\n  var tailCombs = [];\n\n  for (var i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1);\n\n    for (var j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i]].concat(_toConsumableArray(tailCombs[j])));\n    }\n  }\n\n  return combs;\n};\n\nvar thresholdSame = function thresholdSame(arr, t) {\n  var hashMap = {};\n\n  for (var i = 0; i < arr.length; i += 1) {\n    var str = JsonStringify(arr[i]);\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1;\n\n    if (hashMap[str] === t) {\n      return arr[i];\n    }\n  }\n\n  return undefined;\n};\n\nvar keyLookup = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(endpoints, verifier, verifierId) {\n    var lookupPromises;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            lookupPromises = endpoints.map(function (x) {\n              return post(x, generateJsonRPCObject('VerifierLookupRequest', {\n                verifier: verifier,\n                verifier_id: verifierId.toString()\n              })).catch(function (err) {\n                return log.error('lookup request failed', err);\n              });\n            });\n            return _context.abrupt(\"return\", Some(lookupPromises, function (lookupResults) {\n              var lookupShares = lookupResults.filter(function (x1) {\n                return x1;\n              });\n              var errorResult = thresholdSame(lookupShares.map(function (x2) {\n                return x2 && x2.error;\n              }), ~~(endpoints.length / 2) + 1);\n              var keyResult = thresholdSame(lookupShares.map(function (x3) {\n                return x3 && x3.result;\n              }), ~~(endpoints.length / 2) + 1);\n\n              if (keyResult || errorResult) {\n                return Promise.resolve({\n                  keyResult: keyResult,\n                  errorResult: errorResult\n                });\n              }\n\n              return Promise.reject(new Error(\"invalid results \".concat(JSON.stringify(lookupResults))));\n            }));\n\n          case 2:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function keyLookup(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar waitKeyLookup = function waitKeyLookup(endpoints, verifier, verifierId, timeout) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject);\n    }, timeout);\n  });\n};\n\nvar keyAssign = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost, network, nodeNum, initialPoint, data, signedData, acceptedErrorMsgs;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            endpoints = _ref2.endpoints, torusNodePubs = _ref2.torusNodePubs, lastPoint = _ref2.lastPoint, firstPoint = _ref2.firstPoint, verifier = _ref2.verifier, verifierId = _ref2.verifierId, signerHost = _ref2.signerHost, network = _ref2.network;\n\n            if (lastPoint === undefined) {\n              nodeNum = Math.floor(Math.random() * endpoints.length);\n              initialPoint = nodeNum;\n            } else {\n              nodeNum = lastPoint % endpoints.length;\n            }\n\n            if (!(nodeNum === firstPoint)) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw new Error('Looped through all');\n\n          case 4:\n            if (firstPoint !== undefined) initialPoint = firstPoint;\n            data = generateJsonRPCObject('KeyAssign', {\n              verifier: verifier,\n              verifier_id: verifierId.toString()\n            });\n            _context2.prev = 6;\n            _context2.next = 9;\n            return post(signerHost, data, {\n              headers: {\n                pubKeyX: torusNodePubs[nodeNum].X,\n                pubKeyY: torusNodePubs[nodeNum].Y,\n                network: network\n              }\n            }, {\n              useAPIKey: true\n            });\n\n          case 9:\n            signedData = _context2.sent;\n            return _context2.abrupt(\"return\", post(endpoints[nodeNum], _objectSpread$1(_objectSpread$1({}, data), signedData), {\n              headers: {\n                'Content-Type': 'application/json; charset=utf-8'\n              }\n            }));\n\n          case 13:\n            _context2.prev = 13;\n            _context2.t0 = _context2[\"catch\"](6);\n            log.error(_context2.t0);\n            acceptedErrorMsgs = [// Slow node\n            'Timed out', // Happens when the node is not reachable (dns issue etc)\n            'TypeError: Failed to fetch', // All except iOS and Firefox\n            'TypeError: cancelled', // iOS\n            'TypeError: NetworkError when attempting to fetch resource.' // Firefox\n            ];\n\n            if (!acceptedErrorMsgs.includes(_context2.t0.message)) {\n              _context2.next = 19;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", keyAssign({\n              endpoints: endpoints,\n              torusNodePubs: torusNodePubs,\n              lastPoint: nodeNum + 1,\n              firstPoint: initialPoint,\n              verifier: verifier,\n              verifierId: verifierId,\n              signerHost: signerHost,\n              network: network\n            }));\n\n          case 19:\n            throw new Error(\"Sorry, the Torus Network that powers Web3Auth is currently very busy.\\n    We will generate your key in time. Pls try again later. \\n\\n    \".concat(_context2.t0.message || ''));\n\n          case 20:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[6, 13]]);\n  }));\n\n  return function keyAssign(_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n} // of Torus nodes to handle malicious node responses\n\n\nvar Torus = /*#__PURE__*/function () {\n  function Torus() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$enableOneKey = _ref.enableOneKey,\n        enableOneKey = _ref$enableOneKey === void 0 ? false : _ref$enableOneKey,\n        _ref$metadataHost = _ref.metadataHost,\n        metadataHost = _ref$metadataHost === void 0 ? 'https://metadata.tor.us' : _ref$metadataHost,\n        _ref$allowHost = _ref.allowHost,\n        allowHost = _ref$allowHost === void 0 ? 'https://signer.tor.us/api/allow' : _ref$allowHost,\n        _ref$signerHost = _ref.signerHost,\n        signerHost = _ref$signerHost === void 0 ? 'https://signer.tor.us/api/sign' : _ref$signerHost,\n        _ref$serverTimeOffset = _ref.serverTimeOffset,\n        serverTimeOffset = _ref$serverTimeOffset === void 0 ? 0 : _ref$serverTimeOffset,\n        _ref$network = _ref.network,\n        network = _ref$network === void 0 ? 'mainnet' : _ref$network;\n\n    _classCallCheck(this, Torus);\n\n    this.ec = new ec('secp256k1');\n    this.metadataHost = metadataHost;\n    this.allowHost = allowHost;\n    this.enableOneKey = enableOneKey;\n    this.serverTimeOffset = serverTimeOffset || 0; // ms\n\n    this.signerHost = signerHost;\n    this.network = network;\n  }\n\n  _createClass(Torus, [{\n    key: \"getUserTypeAndAddress\",\n    value:\n    /**\n     * Note: use this function only for openlogin tkey account lookups.\n     */\n    function () {\n      var _getUserTypeAndAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(endpoints, torusNodePubs, _ref2) {\n        var verifier,\n            verifierId,\n            doesKeyAssign,\n            _ref3,\n            keyResult,\n            errorResult,\n            isNewKey,\n            finalKeyResult,\n            assignResult,\n            _finalKeyResult$keys$,\n            X,\n            Y,\n            typeOfUser,\n            nonce,\n            pubNonce,\n            modifiedPubKey,\n            upgraded,\n            _yield$this$getOrSetN,\n            finalX,\n            finalY,\n            address,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                verifier = _ref2.verifier, verifierId = _ref2.verifierId;\n                doesKeyAssign = _args.length > 3 && _args[3] !== undefined ? _args[3] : false;\n                _context.next = 4;\n                return keyLookup(endpoints, verifier, verifierId);\n\n              case 4:\n                _context.t0 = _context.sent;\n\n                if (_context.t0) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.t0 = {};\n\n              case 7:\n                _ref3 = _context.t0;\n                keyResult = _ref3.keyResult;\n                errorResult = _ref3.errorResult;\n                isNewKey = false;\n\n                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned'))) {\n                  _context.next = 26;\n                  break;\n                }\n\n                if (doesKeyAssign) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error('Verifier + VerifierID has not yet been assigned');\n\n              case 14:\n                _context.next = 16;\n                return keyAssign({\n                  endpoints: endpoints,\n                  torusNodePubs: torusNodePubs,\n                  lastPoint: undefined,\n                  firstPoint: undefined,\n                  verifier: verifier,\n                  verifierId: verifierId,\n                  signerHost: this.signerHost,\n                  network: this.network\n                });\n\n              case 16:\n                _context.next = 18;\n                return waitKeyLookup(endpoints, verifier, verifierId, 1000);\n\n              case 18:\n                _context.t1 = _context.sent;\n\n                if (_context.t1) {\n                  _context.next = 21;\n                  break;\n                }\n\n                _context.t1 = {};\n\n              case 21:\n                assignResult = _context.t1;\n                finalKeyResult = assignResult.keyResult;\n                isNewKey = true;\n                _context.next = 31;\n                break;\n\n              case 26:\n                if (!keyResult) {\n                  _context.next = 30;\n                  break;\n                }\n\n                finalKeyResult = keyResult;\n                _context.next = 31;\n                break;\n\n              case 30:\n                throw new Error(\"node results do not match at first lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n\n              case 31:\n                if (!finalKeyResult) {\n                  _context.next = 61;\n                  break;\n                }\n\n                _finalKeyResult$keys$ = finalKeyResult.keys[0], X = _finalKeyResult$keys$.pub_key_X, Y = _finalKeyResult$keys$.pub_key_Y;\n                _context.prev = 33;\n                _context.next = 37;\n                return this.getOrSetNonce(X, Y, undefined, !isNewKey);\n\n              case 37:\n                _yield$this$getOrSetN = _context.sent;\n                typeOfUser = _yield$this$getOrSetN.typeOfUser;\n                nonce = _yield$this$getOrSetN.nonce;\n                pubNonce = _yield$this$getOrSetN.pubNonce;\n                upgraded = _yield$this$getOrSetN.upgraded;\n                nonce = new BN(nonce || '0', 16);\n                _context.next = 48;\n                break;\n\n              case 45:\n                _context.prev = 45;\n                _context.t2 = _context[\"catch\"](33);\n                throw new GetOrSetNonceError();\n\n              case 48:\n                if (!(typeOfUser === 'v1')) {\n                  _context.next = 52;\n                  break;\n                }\n\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n                _context.next = 57;\n                break;\n\n              case 52:\n                if (!(typeOfUser === 'v2')) {\n                  _context.next = 56;\n                  break;\n                }\n\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPublic({\n                  x: pubNonce.x,\n                  y: pubNonce.y\n                }).getPublic());\n                _context.next = 57;\n                break;\n\n              case 56:\n                throw new Error('getOrSetNonce should always return typeOfUser.');\n\n              case 57:\n                finalX = modifiedPubKey.getX().toString(16);\n                finalY = modifiedPubKey.getY().toString(16);\n                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n                return _context.abrupt(\"return\", {\n                  typeOfUser: typeOfUser,\n                  nonce: nonce,\n                  pubNonce: pubNonce,\n                  upgraded: upgraded,\n                  X: finalX,\n                  Y: finalY,\n                  address: address\n                });\n\n              case 61:\n                throw new Error(\"node results do not match at final lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n\n              case 62:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[33, 45]]);\n      }));\n\n      function getUserTypeAndAddress(_x, _x2, _x3) {\n        return _getUserTypeAndAddress.apply(this, arguments);\n      }\n\n      return getUserTypeAndAddress;\n    }()\n  }, {\n    key: \"setCustomKey\",\n    value: function () {\n      var _setCustomKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref4) {\n        var privKeyHex, metadataNonce, torusKeyHex, customKeyHex, torusKey, privKey, customKey, newMetadataNonce, data;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                privKeyHex = _ref4.privKeyHex, metadataNonce = _ref4.metadataNonce, torusKeyHex = _ref4.torusKeyHex, customKeyHex = _ref4.customKeyHex;\n\n                if (torusKeyHex) {\n                  torusKey = new BN(torusKeyHex, 16);\n                } else {\n                  privKey = new BN(privKeyHex, 16);\n                  torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n);\n                }\n\n                customKey = new BN(customKeyHex, 16);\n                newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n);\n                data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey.toString(16));\n                _context2.next = 7;\n                return this.setMetadata(data);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function setCustomKey(_x4) {\n        return _setCustomKey.apply(this, arguments);\n      }\n\n      return setCustomKey;\n    }()\n  }, {\n    key: \"retrieveShares\",\n    value: function () {\n      var _retrieveShares = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(endpoints, indexes, verifier, verifierParams, idToken) {\n        var _this = this;\n\n        var extraParams,\n            promiseArr,\n            tmpKey,\n            pubKey,\n            pubKeyX,\n            pubKeyY,\n            tokenCommitment,\n            i,\n            p,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                extraParams = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : {};\n                promiseArr = [];\n                _context5.next = 4;\n                return get(this.allowHost, {\n                  headers: {\n                    verifier: verifier,\n                    verifier_id: verifierParams.verifier_id,\n                    network: this.network\n                  }\n                }, {\n                  useAPIKey: true\n                });\n\n              case 4:\n                /*\n                  CommitmentRequestParams struct {\n                    MessagePrefix      string `json:\"messageprefix\"`\n                    TokenCommitment    string `json:\"tokencommitment\"`\n                    TempPubX           string `json:\"temppubx\"`\n                    TempPubY           string `json:\"temppuby\"`\n                    VerifierIdentifier string `json:\"verifieridentifier\"`\n                  } \n                  */\n                // generate temporary private and public key that is used to secure receive shares\n                tmpKey = generatePrivate();\n                pubKey = getPublic(tmpKey).toString('hex');\n                pubKeyX = pubKey.slice(2, 66);\n                pubKeyY = pubKey.slice(66);\n                tokenCommitment = keccak256(idToken); // make commitment requests to endpoints\n\n                for (i = 0; i < endpoints.length; i += 1) {\n                  p = post(endpoints[i], generateJsonRPCObject('CommitmentRequest', {\n                    messageprefix: 'mug00',\n                    tokencommitment: tokenCommitment.slice(2),\n                    temppubx: pubKeyX,\n                    temppuby: pubKeyY,\n                    verifieridentifier: verifier\n                  })).catch(function (err) {\n                    return log.error('commitment', err);\n                  });\n                  promiseArr.push(p);\n                }\n                /*\n                  ShareRequestParams struct {\n                    Item []bijson.RawMessage `json:\"item\"`\n                  }\n                  ShareRequestItem struct {\n                    IDToken            string          `json:\"idtoken\"`\n                    NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n                    VerifierIdentifier string          `json:\"verifieridentifier\"`\n                  }\n                  NodeSignature struct {\n                    Signature   string\n                    Data        string\n                    NodePubKeyX string\n                    NodePubKeyY string\n                  }\n                  CommitmentRequestResult struct {\n                    Signature string `json:\"signature\"`\n                    Data      string `json:\"data\"`\n                    NodePubX  string `json:\"nodepubx\"`\n                    NodePubY  string `json:\"nodepuby\"`\n                  }\n                  */\n                // send share request once k + t number of commitment requests have completed\n\n\n                return _context5.abrupt(\"return\", Some(promiseArr, function (resultArr) {\n                  var completedRequests = resultArr.filter(function (x) {\n                    if (!x || _typeof(x) !== 'object') {\n                      return false;\n                    }\n\n                    if (x.error) {\n                      return false;\n                    }\n\n                    return true;\n                  });\n\n                  if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n                    return Promise.resolve(resultArr);\n                  }\n\n                  return Promise.reject(new Error(\"invalid \".concat(JSON.stringify(resultArr))));\n                }).then(function (responses) {\n                  var promiseArrRequest = [];\n                  var nodeSigs = [];\n\n                  for (var _i = 0; _i < responses.length; _i += 1) {\n                    if (responses[_i]) nodeSigs.push(responses[_i].result);\n                  }\n\n                  for (var _i2 = 0; _i2 < endpoints.length; _i2 += 1) {\n                    // eslint-disable-next-line promise/no-nesting\n                    var _p = post(endpoints[_i2], generateJsonRPCObject('ShareRequest', {\n                      encrypted: 'yes',\n                      item: [_objectSpread(_objectSpread({}, verifierParams), {}, {\n                        idtoken: idToken,\n                        nodesignatures: nodeSigs,\n                        verifieridentifier: verifier\n                      }, extraParams)]\n                    })).catch(function (err) {\n                      return log.error('share req', err);\n                    });\n\n                    promiseArrRequest.push(_p);\n                  }\n\n                  return Some(promiseArrRequest, /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(shareResponses, sharedState) {\n                      var completedRequests, thresholdPublicKey, sharePromises, nodeIndex, _i3, metadata, sharesResolved, decryptedShares, allCombis, privateKey, _loop, j, _ret;\n\n                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              /*\n                                  ShareRequestResult struct {\n                                    Keys []KeyAssignment\n                                  }\n                                          / KeyAssignmentPublic -\n                                  type KeyAssignmentPublic struct {\n                                    Index     big.Int\n                                    PublicKey common.Point\n                                    Threshold int\n                                    Verifiers map[string][]string // Verifier => VerifierID\n                                  }\n                                   // KeyAssignment -\n                                  type KeyAssignment struct {\n                                    KeyAssignmentPublic\n                                    Share big.Int // Or Si\n                                  }\n                                */\n                              // check if threshold number of nodes have returned the same user public key\n                              completedRequests = shareResponses.filter(function (x) {\n                                return x;\n                              });\n                              thresholdPublicKey = thresholdSame(shareResponses.map(function (x) {\n                                return x && x.result && x.result.keys[0].PublicKey;\n                              }), ~~(endpoints.length / 2) + 1); // optimistically run lagrange interpolation once threshold number of shares have been received\n                              // this is matched against the user public key to ensure that shares are consistent\n\n                              if (!(completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey)) {\n                                _context3.next = 25;\n                                break;\n                              }\n\n                              sharePromises = [];\n                              nodeIndex = [];\n\n                              for (_i3 = 0; _i3 < shareResponses.length; _i3 += 1) {\n                                if (shareResponses[_i3] && shareResponses[_i3].result && shareResponses[_i3].result.keys && shareResponses[_i3].result.keys.length > 0) {\n                                  shareResponses[_i3].result.keys.sort(function (a, b) {\n                                    return new BN(a.Index, 16).cmp(new BN(b.Index, 16));\n                                  });\n\n                                  if (shareResponses[_i3].result.keys[0].Metadata) {\n                                    metadata = {\n                                      ephemPublicKey: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.ephemPublicKey, 'hex'),\n                                      iv: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.iv, 'hex'),\n                                      mac: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mac, 'hex'),\n                                      mode: Buffer.from(shareResponses[_i3].result.keys[0].Metadata.mode, 'hex')\n                                    };\n                                    sharePromises.push( // eslint-disable-next-line promise/no-nesting\n                                    decrypt(tmpKey, _objectSpread(_objectSpread({}, metadata), {}, {\n                                      ciphertext: Buffer.from(atob(shareResponses[_i3].result.keys[0].Share).padStart(64, '0'), 'hex')\n                                    })).catch(function (err) {\n                                      return log.debug('share decryption', err);\n                                    }));\n                                  } else {\n                                    sharePromises.push(Promise.resolve(Buffer.from(shareResponses[_i3].result.keys[0].Share.padStart(64, '0'), 'hex')));\n                                  }\n                                } else {\n                                  sharePromises.push(Promise.resolve(undefined));\n                                }\n\n                                nodeIndex.push(new BN(indexes[_i3], 16));\n                              }\n\n                              _context3.next = 8;\n                              return Promise.all(sharePromises);\n\n                            case 8:\n                              sharesResolved = _context3.sent;\n\n                              if (!sharedState.resolved) {\n                                _context3.next = 11;\n                                break;\n                              }\n\n                              return _context3.abrupt(\"return\", undefined);\n\n                            case 11:\n                              decryptedShares = sharesResolved.reduce(function (acc, curr, index) {\n                                if (curr) acc.push({\n                                  index: nodeIndex[index],\n                                  value: new BN(curr)\n                                });\n                                return acc;\n                              }, []); // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n                              // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n\n                              allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1);\n\n                              _loop = function _loop(j) {\n                                var currentCombi = allCombis[j];\n                                var currentCombiShares = decryptedShares.filter(function (v, index) {\n                                  return currentCombi.includes(index);\n                                });\n                                var shares = currentCombiShares.map(function (x) {\n                                  return x.value;\n                                });\n                                var indices = currentCombiShares.map(function (x) {\n                                  return x.index;\n                                });\n\n                                var derivedPrivateKey = _this.lagrangeInterpolation(shares, indices);\n\n                                var decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex');\n                                var decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n                                var decryptedPubKeyY = decryptedPubKey.slice(66);\n\n                                if (new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 && new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0) {\n                                  privateKey = derivedPrivateKey;\n                                  return \"break\";\n                                }\n                              };\n\n                              j = 0;\n\n                            case 15:\n                              if (!(j < allCombis.length)) {\n                                _context3.next = 22;\n                                break;\n                              }\n\n                              _ret = _loop(j);\n\n                              if (!(_ret === \"break\")) {\n                                _context3.next = 19;\n                                break;\n                              }\n\n                              return _context3.abrupt(\"break\", 22);\n\n                            case 19:\n                              j += 1;\n                              _context3.next = 15;\n                              break;\n\n                            case 22:\n                              if (!(privateKey === undefined)) {\n                                _context3.next = 24;\n                                break;\n                              }\n\n                              throw new Error('could not derive private key');\n\n                            case 24:\n                              return _context3.abrupt(\"return\", privateKey);\n\n                            case 25:\n                              throw new Error('invalid');\n\n                            case 26:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3);\n                    }));\n\n                    return function (_x10, _x11) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }());\n                }).then( /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(returnedKey) {\n                    var privateKey, decryptedPubKey, decryptedPubKeyX, decryptedPubKeyY, metadataNonce, _yield$_this$getNonce, nonce, ethAddress;\n\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            privateKey = returnedKey;\n                            decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), 'hex')).toString('hex');\n                            decryptedPubKeyX = decryptedPubKey.slice(2, 66);\n                            decryptedPubKeyY = decryptedPubKey.slice(66);\n\n                            if (!_this.enableOneKey) {\n                              _context4.next = 12;\n                              break;\n                            }\n\n                            _context4.next = 7;\n                            return _this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey);\n\n                          case 7:\n                            _yield$_this$getNonce = _context4.sent;\n                            nonce = _yield$_this$getNonce.nonce;\n                            metadataNonce = new BN(nonce || '0', 16);\n                            _context4.next = 15;\n                            break;\n\n                          case 12:\n                            _context4.next = 14;\n                            return _this.getMetadata({\n                              pub_key_X: decryptedPubKeyX,\n                              pub_key_Y: decryptedPubKeyY\n                            });\n\n                          case 14:\n                            metadataNonce = _context4.sent;\n\n                          case 15:\n                            log.debug('> torus.js/retrieveShares', {\n                              privKey: privateKey.toString(16),\n                              metadataNonce: metadataNonce.toString(16)\n                            });\n                            privateKey = privateKey.add(metadataNonce).umod(_this.ec.curve.n);\n                            ethAddress = _this.generateAddressFromPrivKey(privateKey);\n                            log.debug('> torus.js/retrieveShares', {\n                              ethAddress: ethAddress,\n                              privKey: privateKey.toString(16)\n                            }); // return reconstructed private key and ethereum address\n\n                            return _context4.abrupt(\"return\", {\n                              ethAddress: ethAddress,\n                              privKey: privateKey.toString('hex', 64),\n                              metadataNonce: metadataNonce\n                            });\n\n                          case 20:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function (_x12) {\n                    return _ref6.apply(this, arguments);\n                  };\n                }()));\n\n              case 11:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function retrieveShares(_x5, _x6, _x7, _x8, _x9) {\n        return _retrieveShares.apply(this, arguments);\n      }\n\n      return retrieveShares;\n    }()\n  }, {\n    key: \"getMetadata\",\n    value: function () {\n      var _getMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(data, options) {\n        var metadataResponse;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n                _context6.next = 3;\n                return post(\"\".concat(this.metadataHost, \"/get\"), data, options, {\n                  useAPIKey: true\n                });\n\n              case 3:\n                metadataResponse = _context6.sent;\n\n                if (!(!metadataResponse || !metadataResponse.message)) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", new BN(0));\n\n              case 6:\n                return _context6.abrupt(\"return\", new BN(metadataResponse.message, 16));\n\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](0);\n                log.error('get metadata error', _context6.t0);\n                return _context6.abrupt(\"return\", new BN(0));\n\n              case 13:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[0, 9]]);\n      }));\n\n      function getMetadata(_x13, _x14) {\n        return _getMetadata.apply(this, arguments);\n      }\n\n      return getMetadata;\n    }()\n  }, {\n    key: \"generateMetadataParams\",\n    value: function generateMetadataParams(message, privateKey) {\n      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64));\n      var setData = {\n        data: message,\n        timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16)\n      };\n      var sig = key.sign(keccak256(JsonStringify(setData)).slice(2));\n      return {\n        pub_key_X: key.getPublic().getX().toString('hex'),\n        pub_key_Y: key.getPublic().getY().toString('hex'),\n        set_data: setData,\n        signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(sig.v).toString(16, 2), 'hex').toString('base64')\n      };\n    }\n  }, {\n    key: \"setMetadata\",\n    value: function () {\n      var _setMetadata = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(data, options) {\n        var metadataResponse;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.prev = 0;\n                _context7.next = 3;\n                return post(\"\".concat(this.metadataHost, \"/set\"), data, options, {\n                  useAPIKey: true\n                });\n\n              case 3:\n                metadataResponse = _context7.sent;\n                return _context7.abrupt(\"return\", metadataResponse.message);\n\n              case 7:\n                _context7.prev = 7;\n                _context7.t0 = _context7[\"catch\"](0);\n                log.error('set metadata error', _context7.t0);\n                return _context7.abrupt(\"return\", '');\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[0, 7]]);\n      }));\n\n      function setMetadata(_x15, _x16) {\n        return _setMetadata.apply(this, arguments);\n      }\n\n      return setMetadata;\n    }()\n  }, {\n    key: \"lagrangeInterpolation\",\n    value: function lagrangeInterpolation(shares, nodeIndex) {\n      if (shares.length !== nodeIndex.length) {\n        return null;\n      }\n\n      var secret = new BN(0);\n\n      for (var i = 0; i < shares.length; i += 1) {\n        var upper = new BN(1);\n        var lower = new BN(1);\n\n        for (var j = 0; j < shares.length; j += 1) {\n          if (i !== j) {\n            upper = upper.mul(nodeIndex[j].neg());\n            upper = upper.umod(this.ec.curve.n);\n            var temp = nodeIndex[i].sub(nodeIndex[j]);\n            temp = temp.umod(this.ec.curve.n);\n            lower = lower.mul(temp).umod(this.ec.curve.n);\n          }\n        }\n\n        var delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n);\n        delta = delta.mul(shares[i]).umod(this.ec.curve.n);\n        secret = secret.add(delta);\n      }\n\n      return secret.umod(this.ec.curve.n);\n    }\n  }, {\n    key: \"generateAddressFromPrivKey\",\n    value: function generateAddressFromPrivKey(privateKey) {\n      var key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex');\n      var publicKey = key.getPublic().encode('hex').slice(2);\n      var ethAddressLower = \"0x\".concat(keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38));\n      return toChecksumAddress(ethAddressLower);\n    }\n  }, {\n    key: \"generateAddressFromPubKey\",\n    value: function generateAddressFromPubKey(publicKeyX, publicKeyY) {\n      var key = this.ec.keyFromPublic({\n        x: publicKeyX.toString('hex', 64),\n        y: publicKeyY.toString('hex', 64)\n      });\n      var publicKey = key.getPublic().encode('hex').slice(2);\n      var ethAddressLower = \"0x\".concat(keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38));\n      return toChecksumAddress(ethAddressLower);\n    }\n    /**\n     * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n     */\n\n  }, {\n    key: \"getPublicAddress\",\n    value: function () {\n      var _getPublicAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(endpoints, torusNodePubs, _ref7) {\n        var verifier,\n            verifierId,\n            isExtended,\n            finalKeyResult,\n            isNewKey,\n            _ref8,\n            keyResult,\n            errorResult,\n            assignResult,\n            _nonce,\n            _finalKeyResult$keys$2,\n            X,\n            Y,\n            typeOfUser,\n            nonce,\n            pubNonce,\n            modifiedPubKey,\n            upgraded,\n            _yield$this$getOrSetN2,\n            address,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                verifier = _ref7.verifier, verifierId = _ref7.verifierId;\n                isExtended = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : false;\n                log.debug('> torus.js/getPublicAddress', {\n                  endpoints: endpoints,\n                  torusNodePubs: torusNodePubs,\n                  verifier: verifier,\n                  verifierId: verifierId,\n                  isExtended: isExtended\n                });\n                isNewKey = false;\n                _context8.next = 6;\n                return keyLookup(endpoints, verifier, verifierId);\n\n              case 6:\n                _context8.t0 = _context8.sent;\n\n                if (_context8.t0) {\n                  _context8.next = 9;\n                  break;\n                }\n\n                _context8.t0 = {};\n\n              case 9:\n                _ref8 = _context8.t0;\n                keyResult = _ref8.keyResult;\n                errorResult = _ref8.errorResult;\n\n                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier not supported'))) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                throw new Error(\"Verifier not supported. Check if you: \\n\\n      1. Are on the right network (Torus testnet/mainnet) \\n\\n      2. Have setup a verifier on dashboard.web3auth.io?\");\n\n              case 16:\n                if (!(errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned'))) {\n                  _context8.next = 29;\n                  break;\n                }\n\n                _context8.next = 19;\n                return keyAssign({\n                  endpoints: endpoints,\n                  torusNodePubs: torusNodePubs,\n                  lastPoint: undefined,\n                  firstPoint: undefined,\n                  verifier: verifier,\n                  verifierId: verifierId,\n                  signerHost: this.signerHost,\n                  network: this.network\n                });\n\n              case 19:\n                _context8.next = 21;\n                return waitKeyLookup(endpoints, verifier, verifierId, 1000);\n\n              case 21:\n                _context8.t1 = _context8.sent;\n\n                if (_context8.t1) {\n                  _context8.next = 24;\n                  break;\n                }\n\n                _context8.t1 = {};\n\n              case 24:\n                assignResult = _context8.t1;\n                finalKeyResult = assignResult.keyResult;\n                isNewKey = true;\n                _context8.next = 34;\n                break;\n\n              case 29:\n                if (!keyResult) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                finalKeyResult = keyResult;\n                _context8.next = 34;\n                break;\n\n              case 33:\n                throw new Error(\"node results do not match at first lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n\n              case 34:\n                log.debug('> torus.js/getPublicAddress', {\n                  finalKeyResult: finalKeyResult,\n                  isNewKey: isNewKey\n                });\n\n                if (!finalKeyResult) {\n                  _context8.next = 76;\n                  break;\n                }\n\n                _finalKeyResult$keys$2 = finalKeyResult.keys[0], X = _finalKeyResult$keys$2.pub_key_X, Y = _finalKeyResult$keys$2.pub_key_Y;\n\n                if (!this.enableOneKey) {\n                  _context8.next = 64;\n                  break;\n                }\n\n                _context8.prev = 38;\n                _context8.next = 42;\n                return this.getOrSetNonce(X, Y, undefined, !isNewKey);\n\n              case 42:\n                _yield$this$getOrSetN2 = _context8.sent;\n                typeOfUser = _yield$this$getOrSetN2.typeOfUser;\n                nonce = _yield$this$getOrSetN2.nonce;\n                pubNonce = _yield$this$getOrSetN2.pubNonce;\n                upgraded = _yield$this$getOrSetN2.upgraded;\n                nonce = new BN(nonce || '0', 16);\n                _context8.next = 53;\n                break;\n\n              case 50:\n                _context8.prev = 50;\n                _context8.t2 = _context8[\"catch\"](38);\n                throw new GetOrSetNonceError();\n\n              case 53:\n                if (!(typeOfUser === 'v1')) {\n                  _context8.next = 57;\n                  break;\n                }\n\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n                _context8.next = 62;\n                break;\n\n              case 57:\n                if (!(typeOfUser === 'v2')) {\n                  _context8.next = 61;\n                  break;\n                }\n\n                if (upgraded) {\n                  // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n                  modifiedPubKey = this.ec.keyFromPublic({\n                    x: X.toString(16),\n                    y: Y.toString(16)\n                  }).getPublic();\n                } else {\n                  modifiedPubKey = this.ec.keyFromPublic({\n                    x: X.toString(16),\n                    y: Y.toString(16)\n                  }).getPublic().add(this.ec.keyFromPublic({\n                    x: pubNonce.x,\n                    y: pubNonce.y\n                  }).getPublic());\n                }\n\n                _context8.next = 62;\n                break;\n\n              case 61:\n                throw new Error('getOrSetNonce should always return typeOfUser.');\n\n              case 62:\n                _context8.next = 69;\n                break;\n\n              case 64:\n                typeOfUser = 'v1';\n                _context8.next = 67;\n                return this.getMetadata({\n                  pub_key_X: X,\n                  pub_key_Y: Y\n                });\n\n              case 67:\n                nonce = _context8.sent;\n                modifiedPubKey = this.ec.keyFromPublic({\n                  x: X.toString(16),\n                  y: Y.toString(16)\n                }).getPublic().add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic());\n\n              case 69:\n                X = modifiedPubKey.getX().toString(16);\n                Y = modifiedPubKey.getY().toString(16);\n                address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY());\n                log.debug('> torus.js/getPublicAddress', {\n                  X: X,\n                  Y: Y,\n                  address: address,\n                  typeOfUser: typeOfUser,\n                  nonce: (_nonce = nonce) === null || _nonce === void 0 ? void 0 : _nonce.toString(16),\n                  pubNonce: pubNonce\n                });\n\n                if (isExtended) {\n                  _context8.next = 75;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", address);\n\n              case 75:\n                return _context8.abrupt(\"return\", {\n                  typeOfUser: typeOfUser,\n                  address: address,\n                  X: X,\n                  Y: Y,\n                  metadataNonce: nonce,\n                  pubNonce: pubNonce\n                });\n\n              case 76:\n                throw new Error(\"node results do not match at final lookup \".concat(JSON.stringify(keyResult || {}), \", \").concat(JSON.stringify(errorResult || {})));\n\n              case 77:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[38, 50]]);\n      }));\n\n      function getPublicAddress(_x17, _x18, _x19) {\n        return _getPublicAddress.apply(this, arguments);\n      }\n\n      return getPublicAddress;\n    }()\n    /**\n     * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n     */\n\n  }, {\n    key: \"getOrSetNonce\",\n    value: function () {\n      var _getOrSetNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(X, Y, privKey) {\n        var getOnly,\n            data,\n            msg,\n            _args9 = arguments;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                getOnly = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : false;\n                msg = getOnly ? 'getNonce' : 'getOrSetNonce';\n\n                if (privKey) {\n                  data = this.generateMetadataParams(msg, privKey);\n                } else {\n                  data = {\n                    pub_key_X: X,\n                    pub_key_Y: Y,\n                    set_data: {\n                      data: msg\n                    }\n                  };\n                }\n\n                return _context9.abrupt(\"return\", post(\"\".concat(this.metadataHost, \"/get_or_set_nonce\"), data, undefined, {\n                  useAPIKey: true\n                }));\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getOrSetNonce(_x20, _x21, _x22) {\n        return _getOrSetNonce.apply(this, arguments);\n      }\n\n      return getOrSetNonce;\n    }()\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(X, Y, privKey) {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this.getOrSetNonce(X, Y, privKey, true));\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getNonce(_x23, _x24, _x25) {\n        return _getNonce.apply(this, arguments);\n      }\n\n      return getNonce;\n    }()\n  }, {\n    key: \"getPostboxKeyFrom1OutOf1\",\n    value: function getPostboxKeyFrom1OutOf1(privKey, nonce) {\n      var privKeyBN = new BN(privKey, 16);\n      var nonceBN = new BN(nonce, 16);\n      return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString('hex');\n    }\n  }], [{\n    key: \"enableLogging\",\n    value: function enableLogging() {\n      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (v) log.enableAll();else log.disableAll();\n    }\n  }, {\n    key: \"setAPIKey\",\n    value: function setAPIKey$1(apiKey) {\n      setAPIKey(apiKey);\n    }\n  }, {\n    key: \"setEmbedHost\",\n    value: function setEmbedHost$1(embedHost) {\n      setEmbedHost(embedHost);\n    }\n  }, {\n    key: \"isGetOrSetNonceError\",\n    value: function isGetOrSetNonceError(err) {\n      return err instanceof GetOrSetNonceError;\n    }\n  }]);\n\n  return Torus;\n}();\n\nexport { Torus as default, keyAssign, keyLookup, waitKeyLookup };","map":{"version":3,"sources":["../src/loglevel.js","../src/some.js","../src/utils.js","../src/torus.js"],"names":["log","loglevel","str","SomeError","errors","responses","predicate","Some","finishedCount","sharedState","resolved","errorArr","promises","resultArr","x","resolve","predicateError","id","error","z","acc","capitalizeFirstLetter","msg","reject","GetOrSetNonceError","kCombinations","set","length","k","combs","tailCombs","i","j","thresholdSame","hashMap","arr","JsonStringify","keyLookup","lookupPromises","generateJsonRPCObject","verifier","verifier_id","verifierId","lookupShares","errorResult","x2","endpoints","keyResult","x3","Promise","JSON","waitKeyLookup","setTimeout","keyAssign","torusNodePubs","lastPoint","firstPoint","signerHost","network","nodeNum","Math","initialPoint","data","signedData","post","headers","pubKeyX","pubKeyY","useAPIKey","acceptedErrorMsgs","Torus","enableOneKey","metadataHost","allowHost","serverTimeOffset","v","setAPIKey","setEmbedHost","doesKeyAssign","isNewKey","assignResult","finalKeyResult","X","Y","typeOfUser","nonce","pubNonce","upgraded","modifiedPubKey","y","finalX","finalY","address","privKeyHex","metadataNonce","torusKeyHex","customKeyHex","torusKey","privKey","customKey","newMetadataNonce","extraParams","promiseArr","get","verifierParams","tmpKey","generatePrivate","pubKey","getPublic","tokenCommitment","keccak256","p","messageprefix","tokencommitment","temppubx","temppuby","verifieridentifier","completedRequests","promiseArrRequest","nodeSigs","encrypted","item","idtoken","nodesignatures","thresholdPublicKey","sharePromises","nodeIndex","shareResponses","a","b","metadata","ephemPublicKey","Buffer","iv","mac","mode","decrypt","ciphertext","atob","indexes","sharesResolved","decryptedShares","index","value","allCombis","currentCombi","currentCombiShares","shares","indices","derivedPrivateKey","decryptedPubKey","decryptedPubKeyX","decryptedPubKeyY","privateKey","pub_key_X","pub_key_Y","ethAddress","metadataResponse","key","setData","timestamp","Date","sig","stringify","set_data","signature","secret","upper","lower","temp","delta","publicKey","ethAddressLower","toChecksumAddress","publicKeyX","publicKeyY","isExtended","err","getOnly","privKeyBN","nonceBN"],"mappings":"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","sourcesContent":["import loglevel from 'loglevel'\n\nconst log = loglevel.getLogger('torus.js')\nlog.disableAll()\n\nexport default log\n","function capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport class SomeError extends Error {\n  constructor({ errors, responses, predicate }) {\n    super('Unable to resolve enough promises.')\n    this.errors = errors\n    this.responses = responses\n    this.predicate = predicate\n  }\n}\n\nexport const Some = (promises, predicate) =>\n  new Promise((resolve, reject) => {\n    let finishedCount = 0\n    const sharedState = { resolved: false }\n    const errorArr = new Array(promises.length).fill(undefined)\n    const resultArr = new Array(promises.length).fill(undefined)\n    let predicateError\n    promises.forEach((x, index) => {\n      x.then((resp) => {\n        resultArr[index] = resp\n        return undefined\n      })\n        .catch((error) => {\n          errorArr[index] = error\n        })\n        .finally(() => {\n          if (sharedState.resolved) return\n          predicate(resultArr.slice(0), sharedState)\n            .then((data) => {\n              sharedState.resolved = true\n              resolve(data)\n              return undefined\n            })\n            .catch((error) => {\n              // log only the last predicate error\n              predicateError = error\n            })\n            .finally((_) => {\n              finishedCount += 1\n              if (finishedCount === promises.length) {\n                const errors = Object.values(\n                  resultArr.reduce((acc, z) => {\n                    const { id, error } = z || {}\n                    if (error?.data?.length > 0) {\n                      if (error.data.startsWith('Error occurred while verifying params')) acc[id] = capitalizeFirstLetter(error.data)\n                      else acc[id] = error.data\n                    }\n                    return acc\n                  }, {})\n                )\n\n                if (errors.length > 0) {\n                  // Format-able errors\n                  const msg = errors.length > 1 ? `\\n${errors.map((it) => `• ${it}`).join('\\n')}` : errors[0]\n                  reject(new Error(msg))\n                } else {\n                  reject(\n                    new SomeError({\n                      errors: errorArr,\n                      responses: resultArr,\n                      predicate: predicateError?.message || predicateError,\n                    })\n                  )\n                }\n              }\n            })\n        })\n    })\n  })\n","import { generateJsonRPCObject, post } from '@toruslabs/http-helpers'\nimport JsonStringify from 'json-stable-stringify'\n\nimport log from './loglevel'\nimport { Some } from './some'\n\nexport class GetOrSetNonceError extends Error {}\n\nexport const kCombinations = (s, k) => {\n  let set = s\n  if (typeof set === 'number') {\n    set = Array.from({ length: set }, (_, i) => i)\n  }\n  if (k > set.length || k <= 0) {\n    return []\n  }\n\n  if (k === set.length) {\n    return [set]\n  }\n\n  if (k === 1) {\n    return set.reduce((acc, cur) => [...acc, [cur]], [])\n  }\n\n  const combs = []\n  let tailCombs = []\n\n  for (let i = 0; i <= set.length - k + 1; i += 1) {\n    tailCombs = kCombinations(set.slice(i + 1), k - 1)\n    for (let j = 0; j < tailCombs.length; j += 1) {\n      combs.push([set[i], ...tailCombs[j]])\n    }\n  }\n\n  return combs\n}\n\nexport const thresholdSame = (arr, t) => {\n  const hashMap = {}\n  for (let i = 0; i < arr.length; i += 1) {\n    const str = JsonStringify(arr[i])\n    hashMap[str] = hashMap[str] ? hashMap[str] + 1 : 1\n    if (hashMap[str] === t) {\n      return arr[i]\n    }\n  }\n  return undefined\n}\n\nexport const keyLookup = async (endpoints, verifier, verifierId) => {\n  const lookupPromises = endpoints.map((x) =>\n    post(\n      x,\n      generateJsonRPCObject('VerifierLookupRequest', {\n        verifier,\n        verifier_id: verifierId.toString(),\n      })\n    ).catch((err) => log.error('lookup request failed', err))\n  )\n  return Some(lookupPromises, (lookupResults) => {\n    const lookupShares = lookupResults.filter((x1) => x1)\n    const errorResult = thresholdSame(\n      lookupShares.map((x2) => x2 && x2.error),\n      ~~(endpoints.length / 2) + 1\n    )\n    const keyResult = thresholdSame(\n      lookupShares.map((x3) => x3 && x3.result),\n      ~~(endpoints.length / 2) + 1\n    )\n    if (keyResult || errorResult) {\n      return Promise.resolve({ keyResult, errorResult })\n    }\n    return Promise.reject(new Error(`invalid results ${JSON.stringify(lookupResults)}`))\n  })\n}\n\nexport const waitKeyLookup = (endpoints, verifier, verifierId, timeout) =>\n  new Promise((resolve, reject) => {\n    setTimeout(() => {\n      keyLookup(endpoints, verifier, verifierId).then(resolve).catch(reject)\n    }, timeout)\n  })\n\nexport const keyAssign = async ({ endpoints, torusNodePubs, lastPoint, firstPoint, verifier, verifierId, signerHost, network }) => {\n  let nodeNum\n  let initialPoint\n  if (lastPoint === undefined) {\n    nodeNum = Math.floor(Math.random() * endpoints.length)\n    initialPoint = nodeNum\n  } else {\n    nodeNum = lastPoint % endpoints.length\n  }\n  if (nodeNum === firstPoint) throw new Error('Looped through all')\n  if (firstPoint !== undefined) initialPoint = firstPoint\n\n  const data = generateJsonRPCObject('KeyAssign', {\n    verifier,\n    verifier_id: verifierId.toString(),\n  })\n  try {\n    const signedData = await post(\n      signerHost,\n      data,\n      {\n        headers: {\n          pubKeyX: torusNodePubs[nodeNum].X,\n          pubKeyY: torusNodePubs[nodeNum].Y,\n          network,\n        },\n      },\n      { useAPIKey: true }\n    )\n    return post(\n      endpoints[nodeNum],\n      { ...data, ...signedData },\n      {\n        headers: {\n          'Content-Type': 'application/json; charset=utf-8',\n        },\n      }\n    )\n  } catch (error) {\n    log.error(error)\n    const acceptedErrorMsgs = [\n      // Slow node\n      'Timed out',\n      // Happens when the node is not reachable (dns issue etc)\n      'TypeError: Failed to fetch', // All except iOS and Firefox\n      'TypeError: cancelled', // iOS\n      'TypeError: NetworkError when attempting to fetch resource.', // Firefox\n    ]\n    if (acceptedErrorMsgs.includes(error.message))\n      return keyAssign({ endpoints, torusNodePubs, lastPoint: nodeNum + 1, firstPoint: initialPoint, verifier, verifierId, signerHost, network })\n    throw new Error(\n      `Sorry, the Torus Network that powers Web3Auth is currently very busy.\n    We will generate your key in time. Pls try again later. \\n\n    ${error.message || ''}`\n    )\n  }\n}\n","import { decrypt, generatePrivate, getPublic } from '@toruslabs/eccrypto'\nimport { generateJsonRPCObject, get, post, setAPIKey, setEmbedHost } from '@toruslabs/http-helpers'\nimport BN from 'bn.js'\nimport { ec as EC } from 'elliptic'\nimport stringify from 'json-stable-stringify'\nimport { keccak256, toChecksumAddress } from 'web3-utils'\n\nimport log from './loglevel'\nimport { Some } from './some'\nimport { GetOrSetNonceError, kCombinations, keyAssign, keyLookup, thresholdSame, waitKeyLookup } from './utils'\n\n// Implement threshold logic wrappers around public APIs\n// of Torus nodes to handle malicious node responses\nclass Torus {\n  constructor({\n    enableOneKey = false,\n    metadataHost = 'https://metadata.tor.us',\n    allowHost = 'https://signer.tor.us/api/allow',\n    signerHost = 'https://signer.tor.us/api/sign',\n    serverTimeOffset = 0,\n    network = 'mainnet',\n  } = {}) {\n    this.ec = new EC('secp256k1')\n    this.metadataHost = metadataHost\n    this.allowHost = allowHost\n    this.enableOneKey = enableOneKey\n    this.serverTimeOffset = serverTimeOffset || 0 // ms\n    this.signerHost = signerHost\n    this.network = network\n  }\n\n  static enableLogging(v = true) {\n    if (v) log.enableAll()\n    else log.disableAll()\n  }\n\n  static setAPIKey(apiKey) {\n    setAPIKey(apiKey)\n  }\n\n  static setEmbedHost(embedHost) {\n    setEmbedHost(embedHost)\n  }\n\n  /**\n   * Note: use this function only for openlogin tkey account lookups.\n   */\n  async getUserTypeAndAddress(endpoints, torusNodePubs, { verifier, verifierId }, doesKeyAssign = false) {\n    const { keyResult, errorResult } = (await keyLookup(endpoints, verifier, verifierId)) || {}\n    let isNewKey = false\n    let finalKeyResult\n    if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {\n      if (!doesKeyAssign) {\n        throw new Error('Verifier + VerifierID has not yet been assigned')\n      }\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network,\n      })\n      const assignResult = (await waitKeyLookup(endpoints, verifier, verifierId, 1000)) || {}\n      finalKeyResult = assignResult.keyResult\n      isNewKey = true\n    } else if (keyResult) {\n      finalKeyResult = keyResult\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n    }\n    if (finalKeyResult) {\n      const { pub_key_X: X, pub_key_Y: Y } = finalKeyResult.keys[0]\n      let typeOfUser\n      let nonce\n      let pubNonce\n      let modifiedPubKey\n      let upgraded\n\n      try {\n        ;({ typeOfUser, nonce, pubNonce, upgraded } = await this.getOrSetNonce(X, Y, undefined, !isNewKey))\n        nonce = new BN(nonce || '0', 16)\n      } catch {\n        throw new GetOrSetNonceError()\n      }\n      if (typeOfUser === 'v1') {\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n      } else if (typeOfUser === 'v2') {\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPublic({ x: pubNonce.x, y: pubNonce.y }).getPublic())\n      } else {\n        throw new Error('getOrSetNonce should always return typeOfUser.')\n      }\n      const finalX = modifiedPubKey.getX().toString(16)\n      const finalY = modifiedPubKey.getY().toString(16)\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY())\n      return { typeOfUser, nonce, pubNonce, upgraded, X: finalX, Y: finalY, address }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n  }\n\n  async setCustomKey({ privKeyHex, metadataNonce, torusKeyHex, customKeyHex }) {\n    let torusKey\n    if (torusKeyHex) {\n      torusKey = new BN(torusKeyHex, 16)\n    } else {\n      const privKey = new BN(privKeyHex, 16)\n      torusKey = privKey.sub(metadataNonce).umod(this.ec.curve.n)\n    }\n    const customKey = new BN(customKeyHex, 16)\n    const newMetadataNonce = customKey.sub(torusKey).umod(this.ec.curve.n)\n    const data = this.generateMetadataParams(newMetadataNonce.toString(16), torusKey.toString(16))\n    await this.setMetadata(data)\n  }\n\n  async retrieveShares(endpoints, indexes, verifier, verifierParams, idToken, extraParams = {}) {\n    const promiseArr = []\n    await get(\n      this.allowHost,\n      {\n        headers: {\n          verifier,\n          verifier_id: verifierParams.verifier_id,\n          network: this.network,\n        },\n      },\n      { useAPIKey: true }\n    )\n    /*\n      CommitmentRequestParams struct {\n        MessagePrefix      string `json:\"messageprefix\"`\n        TokenCommitment    string `json:\"tokencommitment\"`\n        TempPubX           string `json:\"temppubx\"`\n        TempPubY           string `json:\"temppuby\"`\n        VerifierIdentifier string `json:\"verifieridentifier\"`\n      } \n      */\n\n    // generate temporary private and public key that is used to secure receive shares\n    const tmpKey = generatePrivate()\n    const pubKey = getPublic(tmpKey).toString('hex')\n    const pubKeyX = pubKey.slice(2, 66)\n    const pubKeyY = pubKey.slice(66)\n    const tokenCommitment = keccak256(idToken)\n\n    // make commitment requests to endpoints\n    for (let i = 0; i < endpoints.length; i += 1) {\n      const p = post(\n        endpoints[i],\n        generateJsonRPCObject('CommitmentRequest', {\n          messageprefix: 'mug00',\n          tokencommitment: tokenCommitment.slice(2),\n          temppubx: pubKeyX,\n          temppuby: pubKeyY,\n          verifieridentifier: verifier,\n        })\n      ).catch((err) => log.error('commitment', err))\n      promiseArr.push(p)\n    }\n    /*\n      ShareRequestParams struct {\n        Item []bijson.RawMessage `json:\"item\"`\n      }\n      ShareRequestItem struct {\n        IDToken            string          `json:\"idtoken\"`\n        NodeSignatures     []NodeSignature `json:\"nodesignatures\"`\n        VerifierIdentifier string          `json:\"verifieridentifier\"`\n      }\n      NodeSignature struct {\n        Signature   string\n        Data        string\n        NodePubKeyX string\n        NodePubKeyY string\n      }\n      CommitmentRequestResult struct {\n        Signature string `json:\"signature\"`\n        Data      string `json:\"data\"`\n        NodePubX  string `json:\"nodepubx\"`\n        NodePubY  string `json:\"nodepuby\"`\n      }\n      */\n    // send share request once k + t number of commitment requests have completed\n    return Some(promiseArr, (resultArr) => {\n      const completedRequests = resultArr.filter((x) => {\n        if (!x || typeof x !== 'object') {\n          return false\n        }\n        if (x.error) {\n          return false\n        }\n        return true\n      })\n      if (completedRequests.length >= ~~(endpoints.length / 4) * 3 + 1) {\n        return Promise.resolve(resultArr)\n      }\n      return Promise.reject(new Error(`invalid ${JSON.stringify(resultArr)}`))\n    })\n      .then((responses) => {\n        const promiseArrRequest = []\n        const nodeSigs = []\n        for (let i = 0; i < responses.length; i += 1) {\n          if (responses[i]) nodeSigs.push(responses[i].result)\n        }\n        for (let i = 0; i < endpoints.length; i += 1) {\n          // eslint-disable-next-line promise/no-nesting\n          const p = post(\n            endpoints[i],\n            generateJsonRPCObject('ShareRequest', {\n              encrypted: 'yes',\n              item: [{ ...verifierParams, idtoken: idToken, nodesignatures: nodeSigs, verifieridentifier: verifier, ...extraParams }],\n            })\n          ).catch((err) => log.error('share req', err))\n          promiseArrRequest.push(p)\n        }\n        return Some(promiseArrRequest, async (shareResponses, sharedState) => {\n          /*\n              ShareRequestResult struct {\n                Keys []KeyAssignment\n              }\n                      / KeyAssignmentPublic -\n              type KeyAssignmentPublic struct {\n                Index     big.Int\n                PublicKey common.Point\n                Threshold int\n                Verifiers map[string][]string // Verifier => VerifierID\n              }\n\n              // KeyAssignment -\n              type KeyAssignment struct {\n                KeyAssignmentPublic\n                Share big.Int // Or Si\n              }\n            */\n          // check if threshold number of nodes have returned the same user public key\n          const completedRequests = shareResponses.filter((x) => x)\n          const thresholdPublicKey = thresholdSame(\n            shareResponses.map((x) => x && x.result && x.result.keys[0].PublicKey),\n            ~~(endpoints.length / 2) + 1\n          )\n          // optimistically run lagrange interpolation once threshold number of shares have been received\n          // this is matched against the user public key to ensure that shares are consistent\n          if (completedRequests.length >= ~~(endpoints.length / 2) + 1 && thresholdPublicKey) {\n            const sharePromises = []\n            const nodeIndex = []\n            for (let i = 0; i < shareResponses.length; i += 1) {\n              if (shareResponses[i] && shareResponses[i].result && shareResponses[i].result.keys && shareResponses[i].result.keys.length > 0) {\n                shareResponses[i].result.keys.sort((a, b) => new BN(a.Index, 16).cmp(new BN(b.Index, 16)))\n                if (shareResponses[i].result.keys[0].Metadata) {\n                  const metadata = {\n                    ephemPublicKey: Buffer.from(shareResponses[i].result.keys[0].Metadata.ephemPublicKey, 'hex'),\n                    iv: Buffer.from(shareResponses[i].result.keys[0].Metadata.iv, 'hex'),\n                    mac: Buffer.from(shareResponses[i].result.keys[0].Metadata.mac, 'hex'),\n                    mode: Buffer.from(shareResponses[i].result.keys[0].Metadata.mode, 'hex'),\n                  }\n                  sharePromises.push(\n                    // eslint-disable-next-line promise/no-nesting\n                    decrypt(tmpKey, {\n                      ...metadata,\n                      ciphertext: Buffer.from(atob(shareResponses[i].result.keys[0].Share).padStart(64, '0'), 'hex'),\n                    }).catch((err) => log.debug('share decryption', err))\n                  )\n                } else {\n                  sharePromises.push(Promise.resolve(Buffer.from(shareResponses[i].result.keys[0].Share.padStart(64, '0'), 'hex')))\n                }\n              } else {\n                sharePromises.push(Promise.resolve(undefined))\n              }\n              nodeIndex.push(new BN(indexes[i], 16))\n            }\n            const sharesResolved = await Promise.all(sharePromises)\n            if (sharedState.resolved) return undefined\n\n            const decryptedShares = sharesResolved.reduce((acc, curr, index) => {\n              if (curr) acc.push({ index: nodeIndex[index], value: new BN(curr) })\n              return acc\n            }, [])\n            // run lagrange interpolation on all subsets, faster in the optimistic scenario than berlekamp-welch due to early exit\n            const allCombis = kCombinations(decryptedShares.length, ~~(endpoints.length / 2) + 1)\n            let privateKey\n            for (let j = 0; j < allCombis.length; j += 1) {\n              const currentCombi = allCombis[j]\n              const currentCombiShares = decryptedShares.filter((v, index) => currentCombi.includes(index))\n              const shares = currentCombiShares.map((x) => x.value)\n              const indices = currentCombiShares.map((x) => x.index)\n              const derivedPrivateKey = this.lagrangeInterpolation(shares, indices)\n              const decryptedPubKey = getPublic(Buffer.from(derivedPrivateKey.toString(16, 64), 'hex')).toString('hex')\n              const decryptedPubKeyX = decryptedPubKey.slice(2, 66)\n              const decryptedPubKeyY = decryptedPubKey.slice(66)\n              if (\n                new BN(decryptedPubKeyX, 16).cmp(new BN(thresholdPublicKey.X, 16)) === 0 &&\n                new BN(decryptedPubKeyY, 16).cmp(new BN(thresholdPublicKey.Y, 16)) === 0\n              ) {\n                privateKey = derivedPrivateKey\n                break\n              }\n            }\n            if (privateKey === undefined) {\n              throw new Error('could not derive private key')\n            }\n            return privateKey\n          }\n          throw new Error('invalid')\n        })\n      })\n      .then(async (returnedKey) => {\n        let privateKey = returnedKey\n        const decryptedPubKey = getPublic(Buffer.from(privateKey.toString(16, 64), 'hex')).toString('hex')\n        const decryptedPubKeyX = decryptedPubKey.slice(2, 66)\n        const decryptedPubKeyY = decryptedPubKey.slice(66)\n        let metadataNonce\n        if (this.enableOneKey) {\n          const { nonce } = await this.getNonce(decryptedPubKeyX, decryptedPubKeyY, privateKey)\n          metadataNonce = new BN(nonce || '0', 16)\n        } else {\n          metadataNonce = await this.getMetadata({ pub_key_X: decryptedPubKeyX, pub_key_Y: decryptedPubKeyY })\n        }\n        log.debug('> torus.js/retrieveShares', { privKey: privateKey.toString(16), metadataNonce: metadataNonce.toString(16) })\n\n        privateKey = privateKey.add(metadataNonce).umod(this.ec.curve.n)\n\n        const ethAddress = this.generateAddressFromPrivKey(privateKey)\n        log.debug('> torus.js/retrieveShares', { ethAddress, privKey: privateKey.toString(16) })\n\n        // return reconstructed private key and ethereum address\n        return {\n          ethAddress,\n          privKey: privateKey.toString('hex', 64),\n          metadataNonce,\n        }\n      })\n  }\n\n  async getMetadata(data, options) {\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/get`, data, options, { useAPIKey: true })\n      if (!metadataResponse || !metadataResponse.message) {\n        return new BN(0)\n      }\n      return new BN(metadataResponse.message, 16) // nonce\n    } catch (error) {\n      log.error('get metadata error', error)\n      return new BN(0)\n    }\n  }\n\n  generateMetadataParams(message, privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString('hex', 64))\n    const setData = {\n      data: message,\n      timestamp: new BN(~~(this.serverTimeOffset + Date.now() / 1000)).toString(16),\n    }\n    const sig = key.sign(keccak256(stringify(setData)).slice(2))\n    return {\n      pub_key_X: key.getPublic().getX().toString('hex'),\n      pub_key_Y: key.getPublic().getY().toString('hex'),\n      set_data: setData,\n      signature: Buffer.from(sig.r.toString(16, 64) + sig.s.toString(16, 64) + new BN(sig.v).toString(16, 2), 'hex').toString('base64'),\n    }\n  }\n\n  async setMetadata(data, options) {\n    try {\n      const metadataResponse = await post(`${this.metadataHost}/set`, data, options, { useAPIKey: true })\n      return metadataResponse.message // IPFS hash\n    } catch (error) {\n      log.error('set metadata error', error)\n      return ''\n    }\n  }\n\n  lagrangeInterpolation(shares, nodeIndex) {\n    if (shares.length !== nodeIndex.length) {\n      return null\n    }\n    let secret = new BN(0)\n    for (let i = 0; i < shares.length; i += 1) {\n      let upper = new BN(1)\n      let lower = new BN(1)\n      for (let j = 0; j < shares.length; j += 1) {\n        if (i !== j) {\n          upper = upper.mul(nodeIndex[j].neg())\n          upper = upper.umod(this.ec.curve.n)\n          let temp = nodeIndex[i].sub(nodeIndex[j])\n          temp = temp.umod(this.ec.curve.n)\n          lower = lower.mul(temp).umod(this.ec.curve.n)\n        }\n      }\n      let delta = upper.mul(lower.invm(this.ec.curve.n)).umod(this.ec.curve.n)\n      delta = delta.mul(shares[i]).umod(this.ec.curve.n)\n      secret = secret.add(delta)\n    }\n    return secret.umod(this.ec.curve.n)\n  }\n\n  generateAddressFromPrivKey(privateKey) {\n    const key = this.ec.keyFromPrivate(privateKey.toString('hex', 64), 'hex')\n    const publicKey = key.getPublic().encode('hex').slice(2)\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38)}`\n    return toChecksumAddress(ethAddressLower)\n  }\n\n  generateAddressFromPubKey(publicKeyX, publicKeyY) {\n    const key = this.ec.keyFromPublic({ x: publicKeyX.toString('hex', 64), y: publicKeyY.toString('hex', 64) })\n    const publicKey = key.getPublic().encode('hex').slice(2)\n    const ethAddressLower = `0x${keccak256(Buffer.from(publicKey, 'hex')).slice(64 - 38)}`\n    return toChecksumAddress(ethAddressLower)\n  }\n\n  /**\n   * Note: use this function only with custom auth, don't use to lookup openlogin accounts.\n   */\n  async getPublicAddress(endpoints, torusNodePubs, { verifier, verifierId }, isExtended = false) {\n    log.debug('> torus.js/getPublicAddress', { endpoints, torusNodePubs, verifier, verifierId, isExtended })\n\n    let finalKeyResult\n    let isNewKey = false\n\n    const { keyResult, errorResult } = (await keyLookup(endpoints, verifier, verifierId)) || {}\n    if (errorResult && JSON.stringify(errorResult).includes('Verifier not supported')) {\n      // change error msg\n      throw new Error(`Verifier not supported. Check if you: \\n\n      1. Are on the right network (Torus testnet/mainnet) \\n\n      2. Have setup a verifier on dashboard.web3auth.io?`)\n    } else if (errorResult && JSON.stringify(errorResult).includes('Verifier + VerifierID has not yet been assigned')) {\n      await keyAssign({\n        endpoints,\n        torusNodePubs,\n        lastPoint: undefined,\n        firstPoint: undefined,\n        verifier,\n        verifierId,\n        signerHost: this.signerHost,\n        network: this.network,\n      })\n      const assignResult = (await waitKeyLookup(endpoints, verifier, verifierId, 1000)) || {}\n      finalKeyResult = assignResult.keyResult\n      isNewKey = true\n    } else if (keyResult) {\n      finalKeyResult = keyResult\n    } else {\n      throw new Error(`node results do not match at first lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n    }\n    log.debug('> torus.js/getPublicAddress', { finalKeyResult, isNewKey })\n\n    if (finalKeyResult) {\n      let { pub_key_X: X, pub_key_Y: Y } = finalKeyResult.keys[0]\n      let typeOfUser\n      let nonce\n      let pubNonce\n      let modifiedPubKey\n      if (this.enableOneKey) {\n        let upgraded\n        try {\n          ;({ typeOfUser, nonce, pubNonce, upgraded } = await this.getOrSetNonce(X, Y, undefined, !isNewKey))\n          nonce = new BN(nonce || '0', 16)\n        } catch {\n          throw new GetOrSetNonceError()\n        }\n        if (typeOfUser === 'v1') {\n          modifiedPubKey = this.ec\n            .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n            .getPublic()\n            .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n        } else if (typeOfUser === 'v2') {\n          if (upgraded) {\n            // OneKey is upgraded to 2/n, returned address is address of Torus key (postbox key), not tKey\n            modifiedPubKey = this.ec.keyFromPublic({ x: X.toString(16), y: Y.toString(16) }).getPublic()\n          } else {\n            modifiedPubKey = this.ec\n              .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n              .getPublic()\n              .add(this.ec.keyFromPublic({ x: pubNonce.x, y: pubNonce.y }).getPublic())\n          }\n        } else {\n          throw new Error('getOrSetNonce should always return typeOfUser.')\n        }\n      } else {\n        typeOfUser = 'v1'\n        nonce = await this.getMetadata({ pub_key_X: X, pub_key_Y: Y })\n        modifiedPubKey = this.ec\n          .keyFromPublic({ x: X.toString(16), y: Y.toString(16) })\n          .getPublic()\n          .add(this.ec.keyFromPrivate(nonce.toString(16)).getPublic())\n      }\n\n      X = modifiedPubKey.getX().toString(16)\n      Y = modifiedPubKey.getY().toString(16)\n\n      const address = this.generateAddressFromPubKey(modifiedPubKey.getX(), modifiedPubKey.getY())\n      log.debug('> torus.js/getPublicAddress', { X, Y, address, typeOfUser, nonce: nonce?.toString(16), pubNonce })\n\n      if (!isExtended) return address\n      return {\n        typeOfUser,\n        address,\n        X,\n        Y,\n        metadataNonce: nonce,\n        pubNonce,\n      }\n    }\n    throw new Error(`node results do not match at final lookup ${JSON.stringify(keyResult || {})}, ${JSON.stringify(errorResult || {})}`)\n  }\n\n  /**\n   * Internal functions for OneKey (OpenLogin v2), only call these functions if you know what you're doing\n   */\n\n  static isGetOrSetNonceError(err) {\n    return err instanceof GetOrSetNonceError\n  }\n\n  async getOrSetNonce(X, Y, privKey, getOnly = false) {\n    let data\n    const msg = getOnly ? 'getNonce' : 'getOrSetNonce'\n    if (privKey) {\n      data = this.generateMetadataParams(msg, privKey)\n    } else {\n      data = {\n        pub_key_X: X,\n        pub_key_Y: Y,\n        set_data: { data: msg },\n      }\n    }\n    return post(`${this.metadataHost}/get_or_set_nonce`, data, undefined, { useAPIKey: true })\n  }\n\n  async getNonce(X, Y, privKey) {\n    return this.getOrSetNonce(X, Y, privKey, true)\n  }\n\n  getPostboxKeyFrom1OutOf1(privKey, nonce) {\n    const privKeyBN = new BN(privKey, 16)\n    const nonceBN = new BN(nonce, 16)\n    return privKeyBN.sub(nonceBN).umod(this.ec.curve.n).toString('hex')\n  }\n}\n\nexport default Torus\n"]},"metadata":{},"sourceType":"module"}