{"ast":null,"code":"\"use strict\"; // This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BN = require(\"bn.js\");\n\nvar EC = require('elliptic').ec;\n\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\n\nexports.privateKeyExport = function (privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n\n  var d = new BN(privateKey);\n\n  if (d.ucmp(ecparams.n) >= 0) {\n    throw new Error(\"couldn't export to DER format\");\n  }\n\n  var point = ec.g.mul(d);\n  return toPublicKey(point.getX(), point.getY(), compressed);\n};\n\nexports.privateKeyModInverse = function (privateKey) {\n  var bn = new BN(privateKey);\n\n  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n    throw new Error('private key range is invalid');\n  }\n\n  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\n\nexports.signatureImport = function (sigObj) {\n  var r = new BN(sigObj.r);\n\n  if (r.ucmp(ecparams.n) >= 0) {\n    r = new BN(0);\n  }\n\n  var s = new BN(sigObj.s);\n\n  if (s.ucmp(ecparams.n) >= 0) {\n    s = new BN(0);\n  }\n\n  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\n\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  if (compressed === void 0) {\n    compressed = true;\n  }\n\n  var point = ec.keyFromPublic(publicKey);\n  var scalar = new BN(privateKey);\n\n  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n    throw new Error('scalar was invalid (zero or overflow)');\n  }\n\n  var shared = point.pub.mul(scalar);\n  return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\n\nvar toPublicKey = function (x, y, compressed) {\n  var publicKey;\n\n  if (compressed) {\n    publicKey = Buffer.alloc(33);\n    publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n  } else {\n    publicKey = Buffer.alloc(65);\n    publicKey[0] = 0x04;\n    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n  }\n\n  return publicKey;\n};","map":{"version":3,"sources":["../../src/secp256k1v3-lib/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n// This file is imported from secp256k1 v3\n// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BN = require(\"bn.js\");\nvar EC = require('elliptic').ec;\nvar ec = new EC('secp256k1');\nvar ecparams = ec.curve;\nexports.privateKeyExport = function (privateKey, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    var d = new BN(privateKey);\n    if (d.ucmp(ecparams.n) >= 0) {\n        throw new Error(\"couldn't export to DER format\");\n    }\n    var point = ec.g.mul(d);\n    return toPublicKey(point.getX(), point.getY(), compressed);\n};\nexports.privateKeyModInverse = function (privateKey) {\n    var bn = new BN(privateKey);\n    if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {\n        throw new Error('private key range is invalid');\n    }\n    return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);\n};\nexports.signatureImport = function (sigObj) {\n    var r = new BN(sigObj.r);\n    if (r.ucmp(ecparams.n) >= 0) {\n        r = new BN(0);\n    }\n    var s = new BN(sigObj.s);\n    if (s.ucmp(ecparams.n) >= 0) {\n        s = new BN(0);\n    }\n    return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);\n};\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n    if (compressed === void 0) { compressed = true; }\n    var point = ec.keyFromPublic(publicKey);\n    var scalar = new BN(privateKey);\n    if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {\n        throw new Error('scalar was invalid (zero or overflow)');\n    }\n    var shared = point.pub.mul(scalar);\n    return toPublicKey(shared.getX(), shared.getY(), compressed);\n};\nvar toPublicKey = function (x, y, compressed) {\n    var publicKey;\n    if (compressed) {\n        publicKey = Buffer.alloc(33);\n        publicKey[0] = y.isOdd() ? 0x03 : 0x02;\n        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n    }\n    else {\n        publicKey = Buffer.alloc(65);\n        publicKey[0] = 0x04;\n        x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);\n        y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);\n    }\n    return publicKey;\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}