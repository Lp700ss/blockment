{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst bs58_1 = __importDefault(require(\"bs58\")); // TODO: Make sure this polyfill not included when not required\n\n\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\n\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", {\n  fatal: true\n});\n\nfunction baseEncode(value) {\n  if (typeof value === \"string\") {\n    value = Buffer.from(value, \"utf8\");\n  }\n\n  return bs58_1.default.encode(Buffer.from(value));\n}\n\nexports.baseEncode = baseEncode;\n\nfunction baseDecode(value) {\n  return Buffer.from(bs58_1.default.decode(value));\n}\n\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\n\nclass BorshError extends Error {\n  constructor(message) {\n    super(message);\n    this.fieldPath = [];\n    this.originalMessage = message;\n  }\n\n  addToFieldPath(fieldName) {\n    this.fieldPath.splice(0, 0, fieldName); // NOTE: Modifying message directly as jest doesn't use .toString()\n\n    this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n  }\n\n}\n\nexports.BorshError = BorshError; /// Binary encoder.\n\nclass BinaryWriter {\n  constructor() {\n    this.buf = Buffer.alloc(INITIAL_LENGTH);\n    this.length = 0;\n  }\n\n  maybeResize() {\n    if (this.buf.length < 16 + this.length) {\n      this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n    }\n  }\n\n  writeU8(value) {\n    this.maybeResize();\n    this.buf.writeUInt8(value, this.length);\n    this.length += 1;\n  }\n\n  writeU16(value) {\n    this.maybeResize();\n    this.buf.writeUInt16LE(value, this.length);\n    this.length += 2;\n  }\n\n  writeU32(value) {\n    this.maybeResize();\n    this.buf.writeUInt32LE(value, this.length);\n    this.length += 4;\n  }\n\n  writeU64(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n  }\n\n  writeU128(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n  }\n\n  writeU256(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n  }\n\n  writeU512(value) {\n    this.maybeResize();\n    this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n  }\n\n  writeBuffer(buffer) {\n    // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n    this.buf = Buffer.concat([Buffer.from(this.buf.subarray(0, this.length)), buffer, Buffer.alloc(INITIAL_LENGTH)]);\n    this.length += buffer.length;\n  }\n\n  writeString(str) {\n    this.maybeResize();\n    const b = Buffer.from(str, \"utf8\");\n    this.writeU32(b.length);\n    this.writeBuffer(b);\n  }\n\n  writeFixedArray(array) {\n    this.writeBuffer(Buffer.from(array));\n  }\n\n  writeArray(array, fn) {\n    this.maybeResize();\n    this.writeU32(array.length);\n\n    for (const elem of array) {\n      this.maybeResize();\n      fn(elem);\n    }\n  }\n\n  toArray() {\n    return this.buf.subarray(0, this.length);\n  }\n\n}\n\nexports.BinaryWriter = BinaryWriter;\n\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n  const originalMethod = propertyDescriptor.value;\n\n  propertyDescriptor.value = function () {\n    try {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return originalMethod.apply(this, args);\n    } catch (e) {\n      if (e instanceof RangeError) {\n        const code = e.code;\n\n        if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n          throw new BorshError(\"Reached the end of buffer when deserializing\");\n        }\n      }\n\n      throw e;\n    }\n  };\n}\n\nclass BinaryReader {\n  constructor(buf) {\n    this.buf = buf;\n    this.offset = 0;\n  }\n\n  readU8() {\n    const value = this.buf.readUInt8(this.offset);\n    this.offset += 1;\n    return value;\n  }\n\n  readU16() {\n    const value = this.buf.readUInt16LE(this.offset);\n    this.offset += 2;\n    return value;\n  }\n\n  readU32() {\n    const value = this.buf.readUInt32LE(this.offset);\n    this.offset += 4;\n    return value;\n  }\n\n  readU64() {\n    const buf = this.readBuffer(8);\n    return new bn_js_1.default(buf, \"le\");\n  }\n\n  readU128() {\n    const buf = this.readBuffer(16);\n    return new bn_js_1.default(buf, \"le\");\n  }\n\n  readU256() {\n    const buf = this.readBuffer(32);\n    return new bn_js_1.default(buf, \"le\");\n  }\n\n  readU512() {\n    const buf = this.readBuffer(64);\n    return new bn_js_1.default(buf, \"le\");\n  }\n\n  readBuffer(len) {\n    if (this.offset + len > this.buf.length) {\n      throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n    }\n\n    const result = this.buf.slice(this.offset, this.offset + len);\n    this.offset += len;\n    return result;\n  }\n\n  readString() {\n    const len = this.readU32();\n    const buf = this.readBuffer(len);\n\n    try {\n      // NOTE: Using TextDecoder to fail on invalid UTF-8\n      return textDecoder.decode(buf);\n    } catch (e) {\n      throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n    }\n  }\n\n  readFixedArray(len) {\n    return new Uint8Array(this.readBuffer(len));\n  }\n\n  readArray(fn) {\n    const len = this.readU32();\n    const result = Array();\n\n    for (let i = 0; i < len; ++i) {\n      result.push(fn());\n    }\n\n    return result;\n  }\n\n}\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU8\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU16\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU32\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU64\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU128\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU256\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readU512\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readString\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readFixedArray\", null);\n\n__decorate([handlingRangeError], BinaryReader.prototype, \"readArray\", null);\n\nexports.BinaryReader = BinaryReader;\n\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n  try {\n    // TODO: Handle missing values properly (make sure they never result in just skipped write)\n    if (typeof fieldType === \"string\") {\n      writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n    } else if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === \"number\") {\n        if (value.length !== fieldType[0]) {\n          throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n        }\n\n        writer.writeFixedArray(value);\n      } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n        if (value.length !== fieldType[1]) {\n          throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n        }\n\n        for (let i = 0; i < fieldType[1]; i++) {\n          serializeField(schema, null, value[i], fieldType[0], writer);\n        }\n      } else {\n        writer.writeArray(value, item => {\n          serializeField(schema, fieldName, item, fieldType[0], writer);\n        });\n      }\n    } else if (fieldType.kind !== undefined) {\n      switch (fieldType.kind) {\n        case \"option\":\n          {\n            if (value === null || value === undefined) {\n              writer.writeU8(0);\n            } else {\n              writer.writeU8(1);\n              serializeField(schema, fieldName, value, fieldType.type, writer);\n            }\n\n            break;\n          }\n\n        case \"map\":\n          {\n            writer.writeU32(value.size);\n            value.forEach((val, key) => {\n              serializeField(schema, fieldName, key, fieldType.key, writer);\n              serializeField(schema, fieldName, val, fieldType.value, writer);\n            });\n            break;\n          }\n\n        default:\n          throw new BorshError(`FieldType ${fieldType} unrecognized`);\n      }\n    } else {\n      serializeStruct(schema, value, writer);\n    }\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n\n    throw error;\n  }\n}\n\nfunction serializeStruct(schema, obj, writer) {\n  if (typeof obj.borshSerialize === \"function\") {\n    obj.borshSerialize(writer);\n    return;\n  }\n\n  const structSchema = schema.get(obj.constructor);\n\n  if (!structSchema) {\n    throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n  }\n\n  if (structSchema.kind === \"struct\") {\n    structSchema.fields.map(_ref => {\n      let [fieldName, fieldType] = _ref;\n      serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n    });\n  } else if (structSchema.kind === \"enum\") {\n    const name = obj[structSchema.field];\n\n    for (let idx = 0; idx < structSchema.values.length; ++idx) {\n      const [fieldName, fieldType] = structSchema.values[idx];\n\n      if (fieldName === name) {\n        writer.writeU8(idx);\n        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        break;\n      }\n    }\n  } else {\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n  }\n} /// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\n\n\nfunction serialize(schema, obj) {\n  let Writer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BinaryWriter;\n  const writer = new Writer();\n  serializeStruct(schema, obj, writer);\n  return writer.toArray();\n}\n\nexports.serialize = serialize;\n\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n  try {\n    if (typeof fieldType === \"string\") {\n      return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n    }\n\n    if (fieldType instanceof Array) {\n      if (typeof fieldType[0] === \"number\") {\n        return reader.readFixedArray(fieldType[0]);\n      } else if (typeof fieldType[1] === \"number\") {\n        const arr = [];\n\n        for (let i = 0; i < fieldType[1]; i++) {\n          arr.push(deserializeField(schema, null, fieldType[0], reader));\n        }\n\n        return arr;\n      } else {\n        return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n      }\n    }\n\n    if (fieldType.kind === \"option\") {\n      const option = reader.readU8();\n\n      if (option) {\n        return deserializeField(schema, fieldName, fieldType.type, reader);\n      }\n\n      return undefined;\n    }\n\n    if (fieldType.kind === \"map\") {\n      let map = new Map();\n      const length = reader.readU32();\n\n      for (let i = 0; i < length; i++) {\n        const key = deserializeField(schema, fieldName, fieldType.key, reader);\n        const val = deserializeField(schema, fieldName, fieldType.value, reader);\n        map.set(key, val);\n      }\n\n      return map;\n    }\n\n    return deserializeStruct(schema, fieldType, reader);\n  } catch (error) {\n    if (error instanceof BorshError) {\n      error.addToFieldPath(fieldName);\n    }\n\n    throw error;\n  }\n}\n\nfunction deserializeStruct(schema, classType, reader) {\n  if (typeof classType.borshDeserialize === \"function\") {\n    return classType.borshDeserialize(reader);\n  }\n\n  const structSchema = schema.get(classType);\n\n  if (!structSchema) {\n    throw new BorshError(`Class ${classType.name} is missing in schema`);\n  }\n\n  if (structSchema.kind === \"struct\") {\n    const result = {};\n\n    for (const [fieldName, fieldType] of schema.get(classType).fields) {\n      result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n    }\n\n    return new classType(result);\n  }\n\n  if (structSchema.kind === \"enum\") {\n    const idx = reader.readU8();\n\n    if (idx >= structSchema.values.length) {\n      throw new BorshError(`Enum index: ${idx} is out of range`);\n    }\n\n    const [fieldName, fieldType] = structSchema.values[idx];\n    const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n    return new classType({\n      [fieldName]: fieldValue\n    });\n  }\n\n  throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n} /// Deserializes object from bytes using schema.\n\n\nfunction deserialize(schema, classType, buffer) {\n  let Reader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BinaryReader;\n  const reader = new Reader(buffer);\n  const result = deserializeStruct(schema, classType, reader);\n\n  if (reader.offset < buffer.length) {\n    throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n  }\n\n  return result;\n}\n\nexports.deserialize = deserialize; /// Deserializes object from bytes using schema, without checking the length read\n\nfunction deserializeUnchecked(schema, classType, buffer) {\n  let Reader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BinaryReader;\n  const reader = new Reader(buffer);\n  return deserializeStruct(schema, classType, reader);\n}\n\nexports.deserializeUnchecked = deserializeUnchecked;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","d","Reflect","decorate","i","__importStar","mod","__esModule","result","hasOwnProperty","call","__importDefault","exports","deserializeUnchecked","deserialize","serialize","BinaryReader","BinaryWriter","BorshError","baseDecode","baseEncode","bn_js_1","require","bs58_1","encoding","ResolvedTextDecoder","TextDecoder","textDecoder","fatal","Buffer","from","default","encode","decode","INITIAL_LENGTH","Error","constructor","message","fieldPath","originalMessage","addToFieldPath","fieldName","splice","join","buf","alloc","maybeResize","concat","writeU8","writeUInt8","writeU16","writeUInt16LE","writeU32","writeUInt32LE","writeU64","writeBuffer","toArray","writeU128","writeU256","writeU512","buffer","subarray","writeString","str","b","writeFixedArray","array","writeArray","fn","elem","handlingRangeError","propertyKey","propertyDescriptor","originalMethod","args","apply","e","RangeError","code","indexOf","offset","readU8","readUInt8","readU16","readUInt16LE","readU32","readUInt32LE","readU64","readBuffer","readU128","readU256","readU512","len","slice","readString","readFixedArray","Uint8Array","readArray","Array","push","prototype","capitalizeFirstLetter","string","charAt","toUpperCase","serializeField","schema","fieldType","writer","item","kind","type","size","forEach","val","serializeStruct","error","obj","borshSerialize","structSchema","name","fields","map","field","idx","values","Writer","deserializeField","reader","arr","option","Map","set","deserializeStruct","classType","borshDeserialize","fieldValue","Reader"],"sources":["E:/intoweb3/NBlockment/blockment/node_modules/borsh/lib/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst bs58_1 = __importDefault(require(\"bs58\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(require(\"text-encoding-utf-8\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", { fatal: true });\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message) {\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor() {\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH),\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array) {\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function (...args) {\n        try {\n            return originalMethod.apply(this, args);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        }\n        catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for (let i = 0; i < len; ++i) {\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        }\n        else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            }\n            else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for (let i = 0; i < fieldType[1]; i++) {\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            }\n            else {\n                writer.writeArray(value, (item) => {\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        }\n        else if (fieldType.kind !== undefined) {\n            switch (fieldType.kind) {\n                case \"option\": {\n                    if (value === null || value === undefined) {\n                        writer.writeU8(0);\n                    }\n                    else {\n                        writer.writeU8(1);\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\n                    }\n                    break;\n                }\n                case \"map\": {\n                    writer.writeU32(value.size);\n                    value.forEach((val, key) => {\n                        serializeField(schema, fieldName, key, fieldType.key, writer);\n                        serializeField(schema, fieldName, val, fieldType.value, writer);\n                    });\n                    break;\n                }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        }\n        else {\n            serializeStruct(schema, value, writer);\n        }\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    }\n    else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    }\n    else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            }\n            else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for (let i = 0; i < fieldType[1]; i++) {\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            }\n            else {\n                return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for (let i = 0; i < length; i++) {\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({ [fieldName]: fieldValue });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}