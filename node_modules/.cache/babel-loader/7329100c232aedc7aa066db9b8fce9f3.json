{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\n\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\n\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\n\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };","map":{"version":3,"sources":["../src/rpc/solanaRpcMiddlewares.ts","../src/providers/injectedProviders/injectedProviderProxy.ts","../src/providers/injectedProviders/phantom/providerHandlers.ts","../src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","../src/providers/injectedProviders/torus/providerHandlers.ts","../src/providers/injectedProviders/torus/torusInjectedProvider.ts","../src/rpc/JrpcClient.ts","../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","../src/solanaWallet.ts"],"names":["createGetAccountsMiddleware","getAccounts","createAsyncMiddleware","method","next","accounts","response","createRequestAccountsMiddleware","requestAccounts","createGenericJRPCMiddleware","targetMethod","handler","result","createSolanaMiddleware","providerHandlers","getPrivateKey","mergeMiddleware","createChainSwitchMiddleware","switchSolanaChain","createAccountMiddleware","updatePrivatekey","createInjectedProviderProxyMiddleware","provider","res","getPhantomHandlers","injectedProvider","bs58","ethErrors","signTransaction","message","req","txn","Transaction","transaction","signMessage","params","signAndSendTransaction","txRes","signature","signAllTransactions","txns","msg","decodedMsg","PhantomInjectedProvider","BaseProvider","constructor","state","config","chainConfig","chainNamespace","CHAIN_NAMESPACES","SOLANA","switchChain","Promise","setupProvider","solanaMiddleware","injectedProviderProxy","engine","providerFromEngine","lookupNetwork","chainId","getTorusHandlers","data","buf","Buffer","sendTx","messages","TorusInjectedProvider","code","connectedChainId","connectedHexChainId","isHexStrict","parseInt","WalletInitializationError","setupEngine","handleInjectedProviderUpdate","createChainIdMiddleware","end","createProviderConfigMiddleware","providerConfig","createJsonRpcClient","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","getProviderEngineProxy","transactionGenerator","serializedTx","decodedTx","tx","Message","keyPairGenerator","Keypair","keyPair","signedMsg","nacl","_providerEngineProxy","sig","signedTransactions","SolanaPrivateKeyProvider","providerFactory","enable","getProviderHandlers","updateAccount","existingKey","privKey","health","getChainSwitchMiddleware","chainSwitchHandlers","addNewChainConfig","nativeCurrency","rpcUrls","ticker","tickerName","displayName","blockExplorer","chainSwitchMiddleware","getAccountMiddleware","accountHandlers","privateKey","SolanaWallet","requireAllSignatures","signedTransaction","request"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { providerFromEngine, createFetchMiddleware } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport { Transaction, Keypair, Message } from '@solana/web3.js';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$3({}, req));\n    res.result = result;\n  });\n}\n\nconst getPhantomHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const transaction = await injectedProvider.signTransaction(txn);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"signMessage\",\n        params: {\n          message: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signAndSendTransaction: async req => {\n      const message = bs58.decode(req.params.message);\n      const txn = Transaction.from(message);\n      const txRes = await injectedProvider.signAndSendTransaction(txn);\n      return {\n        signature: txRes.signature\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params2, _req$params3;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message) || !((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = req.params.message.map(msg => {\n        const decodedMsg = bs58.decode(msg);\n        return Transaction.from(decodedMsg);\n      });\n      const transaction = await injectedProvider.signAllTransactions(txns);\n      return transaction;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass PhantomInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$2(_objectSpread$2({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const providerHandlers = getPhantomHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork(injectedProvider);\n  }\n\n  async lookupNetwork(_) {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\"; // const genesisHash = await phantomProvider.request<string>({\n    //   method: \"getGenesisHash\",\n    //   params: [],\n    // });\n    // const { chainConfig } = this.config;\n    // if (!genesisHash) throw WalletInitializationError.rpcConnectionError(`Failed to connect with phantom wallet`);\n    // if (chainConfig.chainId !== genesisHash.substring(0, 32))\n    //   throw WalletInitializationError.invalidNetwork(\n    //     `Wallet is connected to wrong network,Please change your network to ${\n    //       SOLANA_NETWORKS[chainConfig.chainId] || chainConfig.displayName\n    //     } from phantom wallet extention.`\n    //   );\n    // return genesisHash.substring(0, 32);\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      const message = await injectedProvider.request({\n        method: \"sign_message\",\n        params: {\n          data: (_req$params = req.params) === null || _req$params === void 0 ? void 0 : _req$params.message\n        }\n      });\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"sign_transaction\",\n        params: {\n          message\n        }\n      });\n      const buf = Buffer.from(response, \"hex\");\n      const sendTx = Transaction.from(buf);\n      return sendTx;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = bs58.decode(req.params.message).toString(\"hex\");\n      const response = await injectedProvider.request({\n        method: \"send_transaction\",\n        params: {\n          message\n        }\n      });\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const messages = [];\n\n      for (const transaction of req.params.message) {\n        const message = bs58.decode(transaction).toString(\"hex\");\n        messages.push(message);\n      }\n\n      const response = await injectedProvider.request({\n        method: \"sign_all_transactions\",\n        params: {\n          message: messages\n        }\n      });\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    chainId,\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const transactionGenerator = serializedTx => {\n    const decodedTx = bs58.decode(serializedTx);\n    const tx = Transaction.populate(Message.from(decodedTx));\n    return tx;\n  };\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    signTransaction: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = transactionGenerator((_req$params2 = req.params) === null || _req$params2 === void 0 ? void 0 : _req$params2.message);\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = transactionGenerator((_req$params5 = req.params) === null || _req$params5 === void 0 ? void 0 : _req$params5.message);\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params6, _req$params7;\n\n      if (!((_req$params6 = req.params) !== null && _req$params6 !== void 0 && _req$params6.message) || !((_req$params7 = req.params) !== null && _req$params7 !== void 0 && _req$params7.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedTransactions = [];\n\n      for (const tx of ((_req$params8 = req.params) === null || _req$params8 === void 0 ? void 0 : _req$params8.message) || []) {\n        var _req$params8;\n\n        const transaction = transactionGenerator(tx);\n        transaction.partialSign(keyPair);\n        signedTransactions.push(transaction);\n      }\n\n      return signedTransactions;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: bs58.encode(transaction.serialize({\n          requireAllSignatures: false\n        }))\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const messages = transactions.map(transaction => {\n      return bs58.encode(transaction.serialize({\n        requireAllSignatures: false\n      }));\n    });\n    const signedTransaction = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: messages\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SolanaPrivateKeyProvider, SolanaWallet, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}