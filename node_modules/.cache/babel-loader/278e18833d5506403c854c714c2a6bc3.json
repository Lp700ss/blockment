{"ast":null,"code":"import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\n\nconst ProviderEngine = require(\"web3-provider-engine\");\n\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\n\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\n\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\n\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\n\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\n\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\n\nclass WalletConnectProvider extends ProviderEngine {\n  constructor(opts) {\n    super({\n      pollingInterval: opts.pollingInterval || 8000\n    });\n    this.bridge = \"https://bridge.walletconnect.org\";\n    this.qrcode = true;\n    this.qrcodeModal = QRCodeModal;\n    this.qrcodeModalOptions = undefined;\n    this.rpc = null;\n    this.infuraId = \"\";\n    this.http = null;\n    this.isConnecting = false;\n    this.connected = false;\n    this.connectCallbacks = [];\n    this.accounts = [];\n    this.chainId = 1;\n    this.rpcUrl = \"\";\n\n    this.enable = async () => {\n      const wc = await this.getWalletConnector();\n\n      if (wc) {\n        this.start();\n        this.subscribeWalletConnector();\n        return wc.accounts;\n      } else {\n        throw new Error(\"Failed to connect to WalleConnect\");\n      }\n    };\n\n    this.request = async payload => {\n      return this.send(payload);\n    };\n\n    this.send = async (payload, callback) => {\n      if (typeof payload === \"string\") {\n        const method = payload;\n        let params = callback;\n\n        if (method === \"personal_sign\") {\n          params = parsePersonalSign(params);\n        }\n\n        return this.sendAsyncPromise(method, params);\n      }\n\n      payload = Object.assign({\n        id: payloadId(),\n        jsonrpc: \"2.0\"\n      }, payload);\n\n      if (payload.method === \"personal_sign\") {\n        payload.params = parsePersonalSign(payload.params);\n      }\n\n      if (callback) {\n        this.sendAsync(payload, callback);\n        return;\n      }\n\n      return this.sendAsyncPromise(payload.method, payload.params);\n    };\n\n    this.onConnect = callback => {\n      this.connectCallbacks.push(callback);\n    };\n\n    this.triggerConnect = result => {\n      if (this.connectCallbacks && this.connectCallbacks.length) {\n        this.connectCallbacks.forEach(callback => callback(result));\n      }\n    };\n\n    this.bridge = opts.connector ? opts.connector.bridge : opts.bridge || \"https://bridge.walletconnect.org\";\n    this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n    this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n    this.qrcodeModalOptions = opts.qrcodeModalOptions;\n    this.wc = opts.connector || new WalletConnect({\n      bridge: this.bridge,\n      qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n      qrcodeModalOptions: this.qrcodeModalOptions,\n      storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n      signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n      clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta\n    });\n    this.rpc = opts.rpc || null;\n\n    if (!this.rpc && (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n      throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n    }\n\n    this.infuraId = opts.infuraId || \"\";\n    this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n    this.initialize();\n  }\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get connector() {\n    return this.wc;\n  }\n\n  get walletMeta() {\n    return this.wc.peerMeta;\n  }\n\n  async disconnect() {\n    this.close();\n  }\n\n  async close() {\n    const wc = await this.getWalletConnector({\n      disableSessionCreation: true\n    });\n    await wc.killSession();\n    await this.onDisconnect();\n  }\n\n  async handleRequest(payload) {\n    try {\n      let response;\n      let result = null;\n      const wc = await this.getWalletConnector();\n\n      switch (payload.method) {\n        case \"wc_killSession\":\n          await this.close();\n          result = null;\n          break;\n\n        case \"eth_accounts\":\n          result = wc.accounts;\n          break;\n\n        case \"eth_coinbase\":\n          result = wc.accounts[0];\n          break;\n\n        case \"eth_chainId\":\n          result = wc.chainId;\n          break;\n\n        case \"net_version\":\n          result = wc.chainId;\n          break;\n\n        case \"eth_uninstallFilter\":\n          this.sendAsync(payload, _ => _);\n          result = true;\n          break;\n\n        default:\n          response = await this.handleOtherRequests(payload);\n      }\n\n      if (response) {\n        return response;\n      }\n\n      return this.formatResponse(payload, result);\n    } catch (error) {\n      this.emit(\"error\", error);\n      throw error;\n    }\n  }\n\n  async handleOtherRequests(payload) {\n    if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n      return this.handleReadRequests(payload);\n    }\n\n    const wc = await this.getWalletConnector();\n    const result = await wc.sendCustomRequest(payload);\n    return this.formatResponse(payload, result);\n  }\n\n  async handleReadRequests(payload) {\n    if (!this.http) {\n      const error = new Error(\"HTTP Connection not available\");\n      this.emit(\"error\", error);\n      throw error;\n    }\n\n    return this.http.send(payload);\n  }\n\n  formatResponse(payload, result) {\n    return {\n      id: payload.id,\n      jsonrpc: payload.jsonrpc,\n      result: result\n    };\n  }\n\n  getWalletConnector() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      disableSessionCreation = false\n    } = opts;\n    return new Promise((resolve, reject) => {\n      const wc = this.wc;\n\n      if (this.isConnecting) {\n        this.onConnect(x => resolve(x));\n      } else if (!wc.connected && !disableSessionCreation) {\n        this.isConnecting = true;\n        wc.on(\"modal_closed\", () => {\n          reject(new Error(\"User closed modal\"));\n        });\n        wc.createSession({\n          chainId: this.chainId\n        }).then(() => {\n          wc.on(\"connect\", (error, payload) => {\n            if (error) {\n              this.isConnecting = false;\n              return reject(error);\n            }\n\n            this.isConnecting = false;\n            this.connected = true;\n\n            if (payload) {\n              this.updateState(payload.params[0]);\n            }\n\n            this.emit(\"connect\");\n            this.triggerConnect(wc);\n            resolve(wc);\n          });\n        }).catch(error => {\n          this.isConnecting = false;\n          reject(error);\n        });\n      } else {\n        if (!this.connected) {\n          this.connected = true;\n          this.updateState(wc.session);\n        }\n\n        resolve(wc);\n      }\n    });\n  }\n\n  async subscribeWalletConnector() {\n    const wc = await this.getWalletConnector();\n    wc.on(\"disconnect\", error => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.onDisconnect();\n    });\n    wc.on(\"session_update\", (error, payload) => {\n      if (error) {\n        this.emit(\"error\", error);\n        return;\n      }\n\n      this.updateState(payload.params[0]);\n    });\n  }\n\n  async onDisconnect() {\n    await this.stop();\n    this.emit(\"close\", 1000, \"Connection closed\");\n    this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n    this.connected = false;\n  }\n\n  async updateState(sessionParams) {\n    const {\n      accounts,\n      chainId,\n      networkId,\n      rpcUrl\n    } = sessionParams;\n\n    if (!this.accounts || accounts && this.accounts !== accounts) {\n      this.accounts = accounts;\n      this.emit(\"accountsChanged\", accounts);\n    }\n\n    if (!this.chainId || chainId && this.chainId !== chainId) {\n      this.chainId = chainId;\n      this.emit(\"chainChanged\", chainId);\n    }\n\n    if (!this.networkId || networkId && this.networkId !== networkId) {\n      this.networkId = networkId;\n      this.emit(\"networkChanged\", networkId);\n    }\n\n    this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n  }\n\n  updateRpcUrl(chainId) {\n    let rpcUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    const rpc = {\n      infuraId: this.infuraId,\n      custom: this.rpc || undefined\n    };\n    rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n\n    if (rpcUrl) {\n      this.rpcUrl = rpcUrl;\n      this.updateHttpConnection();\n    } else {\n      this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n    }\n  }\n\n  updateHttpConnection() {\n    if (this.rpcUrl) {\n      this.http = new HttpConnection(this.rpcUrl);\n      this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n      this.http.on(\"error\", error => this.emit(\"error\", error));\n    }\n  }\n\n  sendAsyncPromise(method, params) {\n    return new Promise((resolve, reject) => {\n      this.sendAsync({\n        id: payloadId(),\n        jsonrpc: \"2.0\",\n        method,\n        params: params || []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        }\n\n        resolve(response.result);\n      });\n    });\n  }\n\n  initialize() {\n    this.updateRpcUrl(this.chainId);\n    this.addProvider(new FixtureSubprovider({\n      eth_hashrate: \"0x00\",\n      eth_mining: false,\n      eth_syncing: true,\n      net_listening: true,\n      web3_clientVersion: `WalletConnect/v1.x.x/javascript`\n    }));\n    this.addProvider(new CacheSubprovider());\n    this.addProvider(new SubscriptionsSubprovider());\n    this.addProvider(new FilterSubprovider());\n    this.addProvider(new NonceSubprovider());\n    this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n    this.addProvider({\n      handleRequest: async (payload, next, end) => {\n        try {\n          const {\n            error,\n            result\n          } = await this.handleRequest(payload);\n          end(error, result);\n        } catch (error) {\n          end(error);\n        }\n      },\n      setEngine: _ => _\n    });\n  }\n\n  configWallet() {\n    return {\n      getAccounts: async cb => {\n        try {\n          const wc = await this.getWalletConnector();\n          const accounts = wc.accounts;\n\n          if (accounts && accounts.length) {\n            cb(null, accounts);\n          } else {\n            cb(new Error(\"Failed to get accounts\"));\n          }\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signMessage([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processPersonalMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processSignTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTransaction: async (txParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.sendTransaction(txParams);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      },\n      processTypedMessage: async (msgParams, cb) => {\n        try {\n          const wc = await this.getWalletConnector();\n          const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n          cb(null, result);\n        } catch (error) {\n          cb(error);\n        }\n      }\n    };\n  }\n\n}\n\nexport default WalletConnectProvider;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import WalletConnect from \"@walletconnect/client\";\nimport QRCodeModal from \"@walletconnect/qrcode-modal\";\nimport HttpConnection from \"@walletconnect/http-connection\";\nimport { payloadId, signingMethods, parsePersonalSign, getRpcUrl } from \"@walletconnect/utils\";\nconst ProviderEngine = require(\"web3-provider-engine\");\nconst CacheSubprovider = require(\"web3-provider-engine/subproviders/cache\");\nconst FixtureSubprovider = require(\"web3-provider-engine/subproviders/fixture\");\nconst FilterSubprovider = require(\"web3-provider-engine/subproviders/filters\");\nconst HookedWalletSubprovider = require(\"web3-provider-engine/subproviders/hooked-wallet\");\nconst NonceSubprovider = require(\"web3-provider-engine/subproviders/nonce-tracker\");\nconst SubscriptionsSubprovider = require(\"web3-provider-engine/subproviders/subscriptions\");\nclass WalletConnectProvider extends ProviderEngine {\n    constructor(opts) {\n        super({ pollingInterval: opts.pollingInterval || 8000 });\n        this.bridge = \"https://bridge.walletconnect.org\";\n        this.qrcode = true;\n        this.qrcodeModal = QRCodeModal;\n        this.qrcodeModalOptions = undefined;\n        this.rpc = null;\n        this.infuraId = \"\";\n        this.http = null;\n        this.isConnecting = false;\n        this.connected = false;\n        this.connectCallbacks = [];\n        this.accounts = [];\n        this.chainId = 1;\n        this.rpcUrl = \"\";\n        this.enable = async () => {\n            const wc = await this.getWalletConnector();\n            if (wc) {\n                this.start();\n                this.subscribeWalletConnector();\n                return wc.accounts;\n            }\n            else {\n                throw new Error(\"Failed to connect to WalleConnect\");\n            }\n        };\n        this.request = async (payload) => {\n            return this.send(payload);\n        };\n        this.send = async (payload, callback) => {\n            if (typeof payload === \"string\") {\n                const method = payload;\n                let params = callback;\n                if (method === \"personal_sign\") {\n                    params = parsePersonalSign(params);\n                }\n                return this.sendAsyncPromise(method, params);\n            }\n            payload = Object.assign({ id: payloadId(), jsonrpc: \"2.0\" }, payload);\n            if (payload.method === \"personal_sign\") {\n                payload.params = parsePersonalSign(payload.params);\n            }\n            if (callback) {\n                this.sendAsync(payload, callback);\n                return;\n            }\n            return this.sendAsyncPromise(payload.method, payload.params);\n        };\n        this.onConnect = (callback) => {\n            this.connectCallbacks.push(callback);\n        };\n        this.triggerConnect = (result) => {\n            if (this.connectCallbacks && this.connectCallbacks.length) {\n                this.connectCallbacks.forEach(callback => callback(result));\n            }\n        };\n        this.bridge = opts.connector\n            ? opts.connector.bridge\n            : opts.bridge || \"https://bridge.walletconnect.org\";\n        this.qrcode = typeof opts.qrcode === \"undefined\" || opts.qrcode !== false;\n        this.qrcodeModal = opts.qrcodeModal || this.qrcodeModal;\n        this.qrcodeModalOptions = opts.qrcodeModalOptions;\n        this.wc =\n            opts.connector ||\n                new WalletConnect({\n                    bridge: this.bridge,\n                    qrcodeModal: this.qrcode ? this.qrcodeModal : undefined,\n                    qrcodeModalOptions: this.qrcodeModalOptions,\n                    storageId: opts === null || opts === void 0 ? void 0 : opts.storageId,\n                    signingMethods: opts === null || opts === void 0 ? void 0 : opts.signingMethods,\n                    clientMeta: opts === null || opts === void 0 ? void 0 : opts.clientMeta,\n                });\n        this.rpc = opts.rpc || null;\n        if (!this.rpc &&\n            (!opts.infuraId || typeof opts.infuraId !== \"string\" || !opts.infuraId.trim())) {\n            throw new Error(\"Missing one of the required parameters: rpc or infuraId\");\n        }\n        this.infuraId = opts.infuraId || \"\";\n        this.chainId = (opts === null || opts === void 0 ? void 0 : opts.chainId) || this.chainId;\n        this.initialize();\n    }\n    get isWalletConnect() {\n        return true;\n    }\n    get connector() {\n        return this.wc;\n    }\n    get walletMeta() {\n        return this.wc.peerMeta;\n    }\n    async disconnect() {\n        this.close();\n    }\n    async close() {\n        const wc = await this.getWalletConnector({ disableSessionCreation: true });\n        await wc.killSession();\n        await this.onDisconnect();\n    }\n    async handleRequest(payload) {\n        try {\n            let response;\n            let result = null;\n            const wc = await this.getWalletConnector();\n            switch (payload.method) {\n                case \"wc_killSession\":\n                    await this.close();\n                    result = null;\n                    break;\n                case \"eth_accounts\":\n                    result = wc.accounts;\n                    break;\n                case \"eth_coinbase\":\n                    result = wc.accounts[0];\n                    break;\n                case \"eth_chainId\":\n                    result = wc.chainId;\n                    break;\n                case \"net_version\":\n                    result = wc.chainId;\n                    break;\n                case \"eth_uninstallFilter\":\n                    this.sendAsync(payload, (_) => _);\n                    result = true;\n                    break;\n                default:\n                    response = await this.handleOtherRequests(payload);\n            }\n            if (response) {\n                return response;\n            }\n            return this.formatResponse(payload, result);\n        }\n        catch (error) {\n            this.emit(\"error\", error);\n            throw error;\n        }\n    }\n    async handleOtherRequests(payload) {\n        if (!signingMethods.includes(payload.method) && payload.method.startsWith(\"eth_\")) {\n            return this.handleReadRequests(payload);\n        }\n        const wc = await this.getWalletConnector();\n        const result = await wc.sendCustomRequest(payload);\n        return this.formatResponse(payload, result);\n    }\n    async handleReadRequests(payload) {\n        if (!this.http) {\n            const error = new Error(\"HTTP Connection not available\");\n            this.emit(\"error\", error);\n            throw error;\n        }\n        return this.http.send(payload);\n    }\n    formatResponse(payload, result) {\n        return {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result: result,\n        };\n    }\n    getWalletConnector(opts = {}) {\n        const { disableSessionCreation = false } = opts;\n        return new Promise((resolve, reject) => {\n            const wc = this.wc;\n            if (this.isConnecting) {\n                this.onConnect((x) => resolve(x));\n            }\n            else if (!wc.connected && !disableSessionCreation) {\n                this.isConnecting = true;\n                wc.on(\"modal_closed\", () => {\n                    reject(new Error(\"User closed modal\"));\n                });\n                wc.createSession({ chainId: this.chainId })\n                    .then(() => {\n                    wc.on(\"connect\", (error, payload) => {\n                        if (error) {\n                            this.isConnecting = false;\n                            return reject(error);\n                        }\n                        this.isConnecting = false;\n                        this.connected = true;\n                        if (payload) {\n                            this.updateState(payload.params[0]);\n                        }\n                        this.emit(\"connect\");\n                        this.triggerConnect(wc);\n                        resolve(wc);\n                    });\n                })\n                    .catch(error => {\n                    this.isConnecting = false;\n                    reject(error);\n                });\n            }\n            else {\n                if (!this.connected) {\n                    this.connected = true;\n                    this.updateState(wc.session);\n                }\n                resolve(wc);\n            }\n        });\n    }\n    async subscribeWalletConnector() {\n        const wc = await this.getWalletConnector();\n        wc.on(\"disconnect\", error => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.onDisconnect();\n        });\n        wc.on(\"session_update\", (error, payload) => {\n            if (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this.updateState(payload.params[0]);\n        });\n    }\n    async onDisconnect() {\n        await this.stop();\n        this.emit(\"close\", 1000, \"Connection closed\");\n        this.emit(\"disconnect\", 1000, \"Connection disconnected\");\n        this.connected = false;\n    }\n    async updateState(sessionParams) {\n        const { accounts, chainId, networkId, rpcUrl } = sessionParams;\n        if (!this.accounts || (accounts && this.accounts !== accounts)) {\n            this.accounts = accounts;\n            this.emit(\"accountsChanged\", accounts);\n        }\n        if (!this.chainId || (chainId && this.chainId !== chainId)) {\n            this.chainId = chainId;\n            this.emit(\"chainChanged\", chainId);\n        }\n        if (!this.networkId || (networkId && this.networkId !== networkId)) {\n            this.networkId = networkId;\n            this.emit(\"networkChanged\", networkId);\n        }\n        this.updateRpcUrl(this.chainId, rpcUrl || \"\");\n    }\n    updateRpcUrl(chainId, rpcUrl = \"\") {\n        const rpc = { infuraId: this.infuraId, custom: this.rpc || undefined };\n        rpcUrl = rpcUrl || getRpcUrl(chainId, rpc);\n        if (rpcUrl) {\n            this.rpcUrl = rpcUrl;\n            this.updateHttpConnection();\n        }\n        else {\n            this.emit(\"error\", new Error(`No RPC Url available for chainId: ${chainId}`));\n        }\n    }\n    updateHttpConnection() {\n        if (this.rpcUrl) {\n            this.http = new HttpConnection(this.rpcUrl);\n            this.http.on(\"payload\", payload => this.emit(\"payload\", payload));\n            this.http.on(\"error\", error => this.emit(\"error\", error));\n        }\n    }\n    sendAsyncPromise(method, params) {\n        return new Promise((resolve, reject) => {\n            this.sendAsync({\n                id: payloadId(),\n                jsonrpc: \"2.0\",\n                method,\n                params: params || [],\n            }, (error, response) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve(response.result);\n            });\n        });\n    }\n    initialize() {\n        this.updateRpcUrl(this.chainId);\n        this.addProvider(new FixtureSubprovider({\n            eth_hashrate: \"0x00\",\n            eth_mining: false,\n            eth_syncing: true,\n            net_listening: true,\n            web3_clientVersion: `WalletConnect/v1.x.x/javascript`,\n        }));\n        this.addProvider(new CacheSubprovider());\n        this.addProvider(new SubscriptionsSubprovider());\n        this.addProvider(new FilterSubprovider());\n        this.addProvider(new NonceSubprovider());\n        this.addProvider(new HookedWalletSubprovider(this.configWallet()));\n        this.addProvider({\n            handleRequest: async (payload, next, end) => {\n                try {\n                    const { error, result } = await this.handleRequest(payload);\n                    end(error, result);\n                }\n                catch (error) {\n                    end(error);\n                }\n            },\n            setEngine: (_) => _,\n        });\n    }\n    configWallet() {\n        return {\n            getAccounts: async (cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const accounts = wc.accounts;\n                    if (accounts && accounts.length) {\n                        cb(null, accounts);\n                    }\n                    else {\n                        cb(new Error(\"Failed to get accounts\"));\n                    }\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signMessage([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processPersonalMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signPersonalMessage([msgParams.data, msgParams.from]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processSignTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTransaction: async (txParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.sendTransaction(txParams);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n            processTypedMessage: async (msgParams, cb) => {\n                try {\n                    const wc = await this.getWalletConnector();\n                    const result = await wc.signTypedData([msgParams.from, msgParams.data]);\n                    cb(null, result);\n                }\n                catch (error) {\n                    cb(error);\n                }\n            },\n        };\n    }\n}\nexport default WalletConnectProvider;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}