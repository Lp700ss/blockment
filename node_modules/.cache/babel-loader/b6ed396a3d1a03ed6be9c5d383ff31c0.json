{"ast":null,"code":"import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n  const _length = (length || 256) / 8;\n\n  const bytes = crypto.randomBytes(_length);\n  const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n  return result;\n}\nexport async function verifyHmac(payload, key) {\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const hmac = encoding.hexToArray(payload.hmac);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const chmac = await crypto.hmacSha256Sign(key, unsigned);\n  const chmacHex = encoding.arrayToHex(chmac, false);\n\n  if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n    return true;\n  }\n\n  return false;\n}\nexport async function encrypt(data, key, providedIv) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n  const ivArrayBuffer = providedIv || (await generateKey(128));\n  const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n  const ivHex = encoding.arrayToHex(iv, false);\n  const contentString = JSON.stringify(data);\n  const content = encoding.utf8ToArray(contentString);\n  const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n  const cipherTextHex = encoding.arrayToHex(cipherText, false);\n  const unsigned = encoding.concatArrays(cipherText, iv);\n  const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n  const hmacHex = encoding.arrayToHex(hmac, false);\n  return {\n    data: cipherTextHex,\n    hmac: hmacHex,\n    iv: ivHex\n  };\n}\nexport async function decrypt(payload, key) {\n  const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n\n  if (!_key) {\n    throw new Error(\"Missing key: required for decryption\");\n  }\n\n  const verified = await verifyHmac(payload, _key);\n\n  if (!verified) {\n    return null;\n  }\n\n  const cipherText = encoding.hexToArray(payload.data);\n  const iv = encoding.hexToArray(payload.iv);\n  const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n  const utf8 = encoding.arrayToUtf8(buffer);\n  let data;\n\n  try {\n    data = JSON.parse(utf8);\n  } catch (error) {\n    return null;\n  }\n\n  return data;\n}","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAZ,MAAwB,uBAAxB;AACA,OAAO,KAAK,QAAZ,MAA0B,yBAA1B;AAOA,SAAS,0BAAT,EAAqC,0BAArC,QAAuE,sBAAvE;AAEA,OAAO,eAAe,WAAf,CAA2B,MAA3B,EAA0C;EAC/C,MAAM,OAAO,GAAG,CAAC,MAAM,IAAI,GAAX,IAAkB,CAAlC;;EACA,MAAM,KAAK,GAAG,MAAM,CAAC,WAAP,CAAmB,OAAnB,CAAd;EACA,MAAM,MAAM,GAAG,0BAA0B,CAAC,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAD,CAAzC;EAEA,OAAO,MAAP;AACD;AAED,OAAO,eAAe,UAAf,CAA0B,OAA1B,EAAuD,GAAvD,EAAsE;EAC3E,MAAM,UAAU,GAAG,QAAQ,CAAC,UAAT,CAAoB,OAAO,CAAC,IAA5B,CAAnB;EACA,MAAM,EAAE,GAAG,QAAQ,CAAC,UAAT,CAAoB,OAAO,CAAC,EAA5B,CAAX;EACA,MAAM,IAAI,GAAG,QAAQ,CAAC,UAAT,CAAoB,OAAO,CAAC,IAA5B,CAAb;EACA,MAAM,OAAO,GAAW,QAAQ,CAAC,UAAT,CAAoB,IAApB,EAA0B,KAA1B,CAAxB;EACA,MAAM,QAAQ,GAAG,QAAQ,CAAC,YAAT,CAAsB,UAAtB,EAAkC,EAAlC,CAAjB;EACA,MAAM,KAAK,GAAG,MAAM,MAAM,CAAC,cAAP,CAAsB,GAAtB,EAA2B,QAA3B,CAApB;EACA,MAAM,QAAQ,GAAW,QAAQ,CAAC,UAAT,CAAoB,KAApB,EAA2B,KAA3B,CAAzB;;EAEA,IAAI,QAAQ,CAAC,eAAT,CAAyB,OAAzB,MAAsC,QAAQ,CAAC,eAAT,CAAyB,QAAzB,CAA1C,EAA8E;IAC5E,OAAO,IAAP;EACD;;EAED,OAAO,KAAP;AACD;AAED,OAAO,eAAe,OAAf,CACL,IADK,EAEL,GAFK,EAGL,UAHK,EAGmB;EAExB,MAAM,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAuB,0BAA0B,CAAC,GAAD,CAAjD,CAAb;;EAEA,MAAM,aAAa,GAAgB,UAAU,KAAK,MAAM,WAAW,CAAC,GAAD,CAAtB,CAA7C;EACA,MAAM,EAAE,GAAG,QAAQ,CAAC,aAAT,CAAuB,0BAA0B,CAAC,aAAD,CAAjD,CAAX;EACA,MAAM,KAAK,GAAW,QAAQ,CAAC,UAAT,CAAoB,EAApB,EAAwB,KAAxB,CAAtB;EAEA,MAAM,aAAa,GAAW,IAAI,CAAC,SAAL,CAAe,IAAf,CAA9B;EACA,MAAM,OAAO,GAAG,QAAQ,CAAC,WAAT,CAAqB,aAArB,CAAhB;EAEA,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,aAAP,CAAqB,EAArB,EAAyB,IAAzB,EAA+B,OAA/B,CAAzB;EACA,MAAM,aAAa,GAAW,QAAQ,CAAC,UAAT,CAAoB,UAApB,EAAgC,KAAhC,CAA9B;EAEA,MAAM,QAAQ,GAAG,QAAQ,CAAC,YAAT,CAAsB,UAAtB,EAAkC,EAAlC,CAAjB;EACA,MAAM,IAAI,GAAG,MAAM,MAAM,CAAC,cAAP,CAAsB,IAAtB,EAA4B,QAA5B,CAAnB;EACA,MAAM,OAAO,GAAW,QAAQ,CAAC,UAAT,CAAoB,IAApB,EAA0B,KAA1B,CAAxB;EAEA,OAAO;IACL,IAAI,EAAE,aADD;IAEL,IAAI,EAAE,OAFD;IAGL,EAAE,EAAE;EAHC,CAAP;AAKD;AAED,OAAO,eAAe,OAAf,CACL,OADK,EAEL,GAFK,EAEW;EAEhB,MAAM,IAAI,GAAG,QAAQ,CAAC,aAAT,CAAuB,0BAA0B,CAAC,GAAD,CAAjD,CAAb;;EAEA,IAAI,CAAC,IAAL,EAAW;IACT,MAAM,IAAI,KAAJ,CAAU,sCAAV,CAAN;EACD;;EAED,MAAM,QAAQ,GAAY,MAAM,UAAU,CAAC,OAAD,EAAU,IAAV,CAA1C;;EACA,IAAI,CAAC,QAAL,EAAe;IACb,OAAO,IAAP;EACD;;EAED,MAAM,UAAU,GAAG,QAAQ,CAAC,UAAT,CAAoB,OAAO,CAAC,IAA5B,CAAnB;EACA,MAAM,EAAE,GAAG,QAAQ,CAAC,UAAT,CAAoB,OAAO,CAAC,EAA5B,CAAX;EACA,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,aAAP,CAAqB,EAArB,EAAyB,IAAzB,EAA+B,UAA/B,CAArB;EACA,MAAM,IAAI,GAAW,QAAQ,CAAC,WAAT,CAAqB,MAArB,CAArB;EACA,IAAI,IAAJ;;EACA,IAAI;IACF,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAP;EACD,CAFD,CAEE,OAAO,KAAP,EAAc;IACd,OAAO,IAAP;EACD;;EAED,OAAO,IAAP;AACD","sourceRoot":"","sourcesContent":["import * as crypto from \"@walletconnect/crypto\";\nimport * as encoding from \"@walletconnect/encoding\";\nimport { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from \"@walletconnect/utils\";\nexport async function generateKey(length) {\n    const _length = (length || 256) / 8;\n    const bytes = crypto.randomBytes(_length);\n    const result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));\n    return result;\n}\nexport async function verifyHmac(payload, key) {\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const hmac = encoding.hexToArray(payload.hmac);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const chmac = await crypto.hmacSha256Sign(key, unsigned);\n    const chmacHex = encoding.arrayToHex(chmac, false);\n    if (encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex)) {\n        return true;\n    }\n    return false;\n}\nexport async function encrypt(data, key, providedIv) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    const ivArrayBuffer = providedIv || (await generateKey(128));\n    const iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));\n    const ivHex = encoding.arrayToHex(iv, false);\n    const contentString = JSON.stringify(data);\n    const content = encoding.utf8ToArray(contentString);\n    const cipherText = await crypto.aesCbcEncrypt(iv, _key, content);\n    const cipherTextHex = encoding.arrayToHex(cipherText, false);\n    const unsigned = encoding.concatArrays(cipherText, iv);\n    const hmac = await crypto.hmacSha256Sign(_key, unsigned);\n    const hmacHex = encoding.arrayToHex(hmac, false);\n    return {\n        data: cipherTextHex,\n        hmac: hmacHex,\n        iv: ivHex,\n    };\n}\nexport async function decrypt(payload, key) {\n    const _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));\n    if (!_key) {\n        throw new Error(\"Missing key: required for decryption\");\n    }\n    const verified = await verifyHmac(payload, _key);\n    if (!verified) {\n        return null;\n    }\n    const cipherText = encoding.hexToArray(payload.data);\n    const iv = encoding.hexToArray(payload.iv);\n    const buffer = await crypto.aesCbcDecrypt(iv, _key, cipherText);\n    const utf8 = encoding.arrayToUtf8(buffer);\n    let data;\n    try {\n        data = JSON.parse(utf8);\n    }\n    catch (error) {\n        return null;\n    }\n    return data;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}