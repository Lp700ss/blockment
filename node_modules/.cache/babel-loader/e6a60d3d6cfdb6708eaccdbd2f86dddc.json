{"ast":null,"code":"import { keccak_256 } from \"js-sha3\";\nimport { removeHexPrefix, addHexPrefix } from \"@walletconnect/encoding\";\nimport { convertUtf8ToHex, convertNumberToHex, convertUtf8ToBuffer } from \"./encoding\";\nimport { sanitizeHex, removeHexLeadingZeros } from \"./misc\";\nimport { isEmptyArray, isHexString, isEmptyString } from \"./validators\";\nexport function toChecksumAddress(address) {\n  address = removeHexPrefix(address.toLowerCase());\n  const hash = removeHexPrefix(keccak_256(convertUtf8ToBuffer(address)));\n  let checksum = \"\";\n\n  for (let i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) > 7) {\n      checksum += address[i].toUpperCase();\n    } else {\n      checksum += address[i];\n    }\n  }\n\n  return addHexPrefix(checksum);\n}\nexport const isValidAddress = address => {\n  if (!address) {\n    return false;\n  } else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n    return false;\n  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false;\n  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n    return true;\n  } else {\n    return address === toChecksumAddress(address);\n  }\n};\nexport function parsePersonalSign(params) {\n  if (!isEmptyArray(params) && !isHexString(params[0])) {\n    params[0] = convertUtf8ToHex(params[0]);\n  }\n\n  return params;\n}\nexport function parseTransactionData(txData) {\n  if (typeof txData.type !== \"undefined\" && txData.type !== \"0\") return txData;\n\n  if (typeof txData.from === \"undefined\" || !isValidAddress(txData.from)) {\n    throw new Error(`Transaction object must include a valid 'from' value.`);\n  }\n\n  function parseHexValues(value) {\n    let result = value;\n\n    if (typeof value === \"number\" || typeof value === \"string\" && !isEmptyString(value)) {\n      if (!isHexString(value)) {\n        result = convertNumberToHex(value);\n      } else if (typeof value === \"string\") {\n        result = sanitizeHex(value);\n      }\n    }\n\n    if (typeof result === \"string\") {\n      result = removeHexLeadingZeros(result);\n    }\n\n    return result;\n  }\n\n  const txDataRPC = {\n    from: sanitizeHex(txData.from),\n    to: typeof txData.to === \"undefined\" ? \"\" : sanitizeHex(txData.to),\n    gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n    gas: typeof txData.gas === \"undefined\" ? typeof txData.gasLimit === \"undefined\" ? \"\" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),\n    value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n    nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n    data: typeof txData.data === \"undefined\" ? \"\" : sanitizeHex(txData.data) || \"0x\"\n  };\n  const prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n  Object.keys(txDataRPC).forEach(key => {\n    if (!txDataRPC[key].trim().length && prunable.includes(key)) {\n      delete txDataRPC[key];\n    }\n  });\n  return txDataRPC;\n}","map":{"version":3,"sources":["../../src/ethereum.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { keccak_256 } from \"js-sha3\";\nimport { removeHexPrefix, addHexPrefix } from \"@walletconnect/encoding\";\nimport { convertUtf8ToHex, convertNumberToHex, convertUtf8ToBuffer } from \"./encoding\";\nimport { sanitizeHex, removeHexLeadingZeros } from \"./misc\";\nimport { isEmptyArray, isHexString, isEmptyString } from \"./validators\";\nexport function toChecksumAddress(address) {\n    address = removeHexPrefix(address.toLowerCase());\n    const hash = removeHexPrefix(keccak_256(convertUtf8ToBuffer(address)));\n    let checksum = \"\";\n    for (let i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) > 7) {\n            checksum += address[i].toUpperCase();\n        }\n        else {\n            checksum += address[i];\n        }\n    }\n    return addHexPrefix(checksum);\n}\nexport const isValidAddress = (address) => {\n    if (!address) {\n        return false;\n    }\n    else if (address.toLowerCase().substring(0, 2) !== \"0x\") {\n        return false;\n    }\n    else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n        return false;\n    }\n    else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {\n        return true;\n    }\n    else {\n        return address === toChecksumAddress(address);\n    }\n};\nexport function parsePersonalSign(params) {\n    if (!isEmptyArray(params) && !isHexString(params[0])) {\n        params[0] = convertUtf8ToHex(params[0]);\n    }\n    return params;\n}\nexport function parseTransactionData(txData) {\n    if (typeof txData.type !== \"undefined\" && txData.type !== \"0\")\n        return txData;\n    if (typeof txData.from === \"undefined\" || !isValidAddress(txData.from)) {\n        throw new Error(`Transaction object must include a valid 'from' value.`);\n    }\n    function parseHexValues(value) {\n        let result = value;\n        if (typeof value === \"number\" || (typeof value === \"string\" && !isEmptyString(value))) {\n            if (!isHexString(value)) {\n                result = convertNumberToHex(value);\n            }\n            else if (typeof value === \"string\") {\n                result = sanitizeHex(value);\n            }\n        }\n        if (typeof result === \"string\") {\n            result = removeHexLeadingZeros(result);\n        }\n        return result;\n    }\n    const txDataRPC = {\n        from: sanitizeHex(txData.from),\n        to: typeof txData.to === \"undefined\" ? \"\" : sanitizeHex(txData.to),\n        gasPrice: typeof txData.gasPrice === \"undefined\" ? \"\" : parseHexValues(txData.gasPrice),\n        gas: typeof txData.gas === \"undefined\"\n            ? typeof txData.gasLimit === \"undefined\"\n                ? \"\"\n                : parseHexValues(txData.gasLimit)\n            : parseHexValues(txData.gas),\n        value: typeof txData.value === \"undefined\" ? \"\" : parseHexValues(txData.value),\n        nonce: typeof txData.nonce === \"undefined\" ? \"\" : parseHexValues(txData.nonce),\n        data: typeof txData.data === \"undefined\" ? \"\" : sanitizeHex(txData.data) || \"0x\",\n    };\n    const prunable = [\"gasPrice\", \"gas\", \"value\", \"nonce\"];\n    Object.keys(txDataRPC).forEach((key) => {\n        if (!txDataRPC[key].trim().length && prunable.includes(key)) {\n            delete txDataRPC[key];\n        }\n    });\n    return txDataRPC;\n}\n//# sourceMappingURL=ethereum.js.map"]},"metadata":{},"sourceType":"module"}