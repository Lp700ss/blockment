{"ast":null,"code":"const cacheUtils = require('./cache-utils.js');\n\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware'); // `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\n\n\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e'];\nmodule.exports = createBlockCacheMiddleware;\n\nfunction createBlockCacheMiddleware() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // validate options\n  const {\n    blockTracker\n  } = opts;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified'); // create caching strategies\n\n  const blockCache = new BlockCacheStrategy();\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next();\n    } // check type and matching strategy\n\n\n    const type = cacheUtils.cacheTypeForPayload(req);\n    const strategy = strategies[type]; // If there's no strategy in place, pass it down the chain.\n\n    if (!strategy) {\n      return next();\n    } // If the strategy can't cache this request, ignore it.\n\n\n    if (!strategy.canCacheRequest(req)) {\n      return next();\n    } // get block reference (number or keyword)\n\n\n    let blockTag = cacheUtils.blockTagForPayload(req);\n    if (!blockTag) blockTag = 'latest'; // get exact block number\n\n    let requestedBlockNumber;\n\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00';\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock(); // clear all cache before latest block\n\n      blockCache.clearBefore(latestBlockNumber);\n      requestedBlockNumber = latestBlockNumber;\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag;\n    } // end on a hit, continue on a miss\n\n\n    const cacheResult = await strategy.get(req, requestedBlockNumber);\n\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next(); // add result to cache\n\n      await strategy.set(req, requestedBlockNumber, res.result);\n    } else {\n      // fill in result from cache\n      res.result = cacheResult;\n    }\n  });\n} //\n// Cache Strategies\n//\n\n\nclass BlockCacheStrategy {\n  constructor() {\n    this.cache = {};\n  }\n\n  getBlockCacheForPayload(payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16);\n    let blockCache = this.cache[blockNumber]; // create new cache if necesary\n\n    if (!blockCache) {\n      const newCache = {};\n      this.cache[blockNumber] = newCache;\n      blockCache = newCache;\n    }\n\n    return blockCache;\n  }\n\n  async get(payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    if (!blockCache) return; // lookup payload in block cache\n\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n    const cached = blockCache[identifier]; // may be undefined\n\n    return cached;\n  }\n\n  async set(payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result);\n    if (!canCache) return; // set the value in the cache\n\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n    blockCache[identifier] = result;\n  }\n\n  canCacheRequest(payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false;\n    } // check blockTag\n\n\n    const blockTag = cacheUtils.blockTagForPayload(payload);\n\n    if (blockTag === 'pending') {\n      return false;\n    } // can be cached\n\n\n    return true;\n  }\n\n  canCacheResult(payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return; // check if transactions have block reference before caching\n\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false;\n      }\n    } // otherwise true\n\n\n    return true;\n  } // removes all block caches with block number lower than `oldBlockHex`\n\n\n  clearBefore(oldBlockHex) {\n    const self = this;\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16); // clear old caches\n\n    Object.keys(self.cache).map(Number).filter(num => num < oldBlockNumber).forEach(num => delete self.cache[num]);\n  }\n\n}","map":{"version":3,"names":["cacheUtils","require","createAsyncMiddleware","emptyValues","undefined","module","exports","createBlockCacheMiddleware","opts","blockTracker","Error","blockCache","BlockCacheStrategy","strategies","perma","block","fork","req","res","next","skipCache","type","cacheTypeForPayload","strategy","canCacheRequest","blockTag","blockTagForPayload","requestedBlockNumber","latestBlockNumber","getLatestBlock","clearBefore","cacheResult","get","set","result","constructor","cache","getBlockCacheForPayload","payload","blockNumberHex","blockNumber","Number","parseInt","newCache","identifier","cacheIdentifierForPayload","cached","canCache","canCacheResult","includes","method","blockHash","oldBlockHex","self","oldBlockNumber","Object","keys","map","filter","num","forEach"],"sources":["E:/intoweb3/NBlockment/blockment/node_modules/eth-json-rpc-middleware/block-cache.js"],"sourcesContent":["const cacheUtils = require('./cache-utils.js')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e']\n\nmodule.exports = createBlockCacheMiddleware\n\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const { blockTracker } = opts\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy()\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache,\n  }\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next()\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req)\n    const strategy = strategies[type]\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next()\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next()\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req)\n    if (!blockTag) blockTag = 'latest'\n\n    // get exact block number\n    let requestedBlockNumber\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00'\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock()\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber)\n      requestedBlockNumber = latestBlockNumber\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber)\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next()\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result)\n    } else {\n      // fill in result from cache\n      res.result = cacheResult\n    }\n  })\n}\n\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  \n  constructor () {\n    this.cache = {}\n  }\n\n  getBlockCacheForPayload (payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16)\n    let blockCache = this.cache[blockNumber]\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {}\n      this.cache[blockNumber] = newCache\n      blockCache = newCache\n    }\n    return blockCache\n  }\n\n  async get (payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    if (!blockCache) return\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    const cached = blockCache[identifier]\n    // may be undefined\n    return cached\n  }\n\n  async set (payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result)\n    if (!canCache) return\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    blockCache[identifier] = result\n  }\n\n  canCacheRequest (payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload)\n    if (blockTag === 'pending') {\n      return false\n    }\n    // can be cached\n    return true\n  }\n\n  canCacheResult (payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false\n      }\n    }\n    // otherwise true\n    return true\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore (oldBlockHex){\n    const self = this\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)\n    // clear old caches\n    Object.keys(self.cache)\n      .map(Number)\n      .filter(num => num < oldBlockNumber)\n      .forEach(num => delete self.cache[num])\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}